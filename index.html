<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hodeng28.github.io","root":"/","scheme":"Muse","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="헤헤">
<meta property="og:type" content="website">
<meta property="og:title" content="hodeng">
<meta property="og:url" content="http://hodeng28.github.io/index.html">
<meta property="og:site_name" content="hodeng">
<meta property="og:description" content="헤헤">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="hodeng28">
<meta property="article:tag" content="javaScript">
<meta property="article:tag" content=" js">
<meta property="article:tag" content=" react">
<meta property="article:tag" content=" angular">
<meta property="article:tag" content=" HTML">
<meta property="article:tag" content=" CSS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://hodeng28.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>hodeng</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hodeng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">호뎅의 개발블로그</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/03/js.ProtoType/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/js.ProtoType/" class="post-title-link" itemprop="url">js.ProtoType</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-04 22:55:18" itemprop="dateCreated datePublished" datetime="2020-03-04T22:55:18+09:00">2020-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 20:30:16" itemprop="dateModified" datetime="2020-03-10T20:30:16+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><h2 id="1-객체지향-프로그래밍-OPP-Object-Oriented-Programming"><a href="#1-객체지향-프로그래밍-OPP-Object-Oriented-Programming" class="headerlink" title="1. 객체지향 프로그래밍 (OPP, Object Oriented Programming)"></a>1. 객체지향 프로그래밍 (OPP, Object Oriented Programming)</h2><ul>
<li>객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임</li>
<li>상태 데이터와 동작을 하나의 논리적 단위로 묶음 복합적인 자료구조</li>
<li>객체의 상태 데이터 - 프로퍼티(property), 동작 - 메소드(method)</li>
<li>각각의 객체는 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 갖을 수 있다.</li>
</ul>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><ul>
<li>객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있다.</li>
<li>프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. </li>
<li>동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. -&gt; 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토 타입에 추가한다.</span></span><br><span class="line"><span class="comment">// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어있다.</span></span><br><span class="line">Circle.prototype.getArea = funciton = () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * MAth.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는 프로토타입</span></span><br><span class="line"><span class="comment">//Circle.prototype로부터 getArea 메소드를 상속받는다.</span></span><br><span class="line"><span class="comment">//즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.14~</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.56~</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getArea 메소드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메소드로 할당</li>
<li>Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메소드를 상속받아 사용할 수 있다.</li>
<li>자신의 상태를 나타내는 radius 프로퍼티만을 개별적으로 소유하고 내용이 동일한 메소드는 상속을 통해 공유하여 사용하는 것이다.</li>
</ul>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><ul>
<li>모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖고, 생성될 때 [[Prototype]]내부 슬롯의 값으로 프로토타입의 참조를 저장한다.</li>
<li>모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다.</li>
<li>프로토타입은 객체이거나 null.  모든 프로토타입은 생성자 함수와 연결되어 있다.</li>
<li>객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</li>
</ul>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3.1 proto 접근자 프로퍼티"></a>3.1 <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다.</li>
<li>모든 객체는 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근하기 위해 <strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</li>
<li>내부 슬롯은 프로퍼티가 아니다. <strong>proto</strong> 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있다.</li>
<li>Object.prototype.<strong>proto</strong> 는 접근자 프로퍼티이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득</span></span><br><span class="line">obj.__proto__;</span><br><span class="line"><span class="comment">// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체</span></span><br><span class="line">obj.__proto__ = parent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x);   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>get <strong>proto</strong> 는 [[GetPrototypeOf]] 내부 메소드를 호출하여 자신의 프로토타입을 취득</p>
</li>
<li><p>set <strong>proto</strong> 은 [[SetPrototypeOf]] 내부 메소드를 호출하여 새로운 프로토타입을 할당한다.</p>
</li>
<li><p><strong>proto</strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다.  모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
</li>
<li><p>프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참좀에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> child = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">child.__proto__ = parent;</span><br><span class="line">parent.__proto__ = child;    <span class="comment">//TypeError: Cyclic __proto__ value</span></span><br></pre></td></tr></table></figure></li>
<li><p>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.</p>
</li>
<li><p>순환 참조적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 무한루프에 빠진다.</p>
</li>
<li><p><strong>proto</strong> 접근자 프로퍼티 대신 프로토타입의 참조를 취득할  경우는 Object.getPrototypeOf메소드, 프로토타입을 교체하는 경우는 Object.setPrototypeOf 메소드를 사용하는 것을 권장</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">//obj 객체의 포로토타입을 취득</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);   <span class="comment">//obj.__proto__;</span></span><br><span class="line"><span class="comment">//obj 객체의 프로토타입을 교체</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj, parent);   <span class="comment">//obj.__proto__ = parent;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3.2 함수 객체의 prototype 프로퍼티"></a>3.2 함수 객체의 prototype 프로퍼티</h3><ul>
<li><p>함수 객체는 <strong>proto</strong> 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다.</p>
</li>
<li><p>함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
</li>
<li><p>생성자 함수로서 호출할 수 없는 함수,  Arrow, Method인 함수 (non-constructor)는 프로토타입이 생성되지 않으며 prototype 프로퍼티도 소유하지 않는다.</p>
</li>
<li><p>모든 객체가 가지고 있는 <strong>proto</strong> 접근자 프로퍼티와  함수 객체만이 가지고 있는 prototype 프로퍼티는 동일한 프로토타입을 가리킨다. (프로퍼티를 사용하는 주체는 다르다)</p>
</li>
</ul>
<h3 id="3-3-프로로타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로로타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3.3 프로로타입의 constructor 프로퍼티와 생성자 함수"></a>3.3 프로로타입의 constructor 프로퍼티와 생성자 함수</h3><ul>
<li>모든 프로토타입은 constructor 프로퍼티를 갖는다.</li>
<li>constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. </li>
<li>연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Jung'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//me 객체의 생성자 함수는 Person이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person);    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로포타입인 Person.prototype에 constructor 프로퍼티가 있다.  상속받아서 사용할 수 있다.</li>
</ul>
<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토-타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토-타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토 타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토 타입</h2><p>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj 객체를 생성한 생성자 함수는 Object이다.</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//add 함수 객체를 생성한 생성자 함수는 Function이다.</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'return a+b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//생성자 함수 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//me 객체를 생성한 생성자 함수는 Person이다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Jung'</span>);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/03/js.firstClassObject/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/js.firstClassObject/" class="post-title-link" itemprop="url">js.firstClassObject</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 18:36:38" itemprop="dateCreated datePublished" datetime="2020-03-03T18:36:38+09:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-05 21:50:25" itemprop="dateModified" datetime="2020-03-05T21:50:25+09:00">2020-03-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h2 id="1-일급-객체-first-class-object"><a href="#1-일급-객체-first-class-object" class="headerlink" title="1. 일급 객체 (first-class object)"></a>1. 일급 객체 (first-class object)</h2><ol>
<li>무명의 리터럴로 생성할 수 있다. (런타임에 생성 가능)</li>
<li>변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개 변수에 전달할 수 있다.</li>
<li>함수의 결과값으로 반환할 수 있다.</li>
</ol>
<p>함수는 === 일급객체</p>
<ul>
<li>일급객체인 함수는 객체와 동일하게 사용할 수 있다. 객체 = 값, 함수 = 값</li>
<li>함수는 값을 사용할 수 있는 곳 어디서든지 리터럴로 정의할 수 있으며, 런타임에<br>함수 객체로 평가 된다.</li>
<li>고유 프로퍼티를 갖는 것, 호출할 수 있는 것을 제외하면 일반객체와 동일하다.</li>
<li>일반 객체처럼 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수 있다. (고차함수)</li>
<li>고유 프로퍼티(데이터) (arguments, caller, length, name, prototype)</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><h3 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2.1 arguments 프로퍼티"></a>2.1 arguments 프로퍼티</h3><ul>
<li>함수 객체의 arguments 프로퍼티 값은 arguments 객체</li>
<li>함수 호출시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable)    유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다.</li>
<li>외부에서는 사용 불가</li>
<li>함수 호출시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. </li>
<li>함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고, undefined로 초기화된 이후 인수가 할당된다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc());   <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(abc(<span class="number">1</span>));  <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(abc(<span class="number">1</span>, <span class="number">2</span>));  <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(abc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));  <span class="comment">//3</span></span><br></pre></td></tr></table></figure></li>
<li>argunmets 객체는 인수를 프로퍼티 값으로 소유하며, 프로퍼티 키는 인수의 순서를 나타낸다.</li>
<li>length 프로퍼티는 인수의 개수를 가리킨다.</li>
<li>arguments 객체는 매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">  res += <span class="built_in">arguments</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum());          <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>));      <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌<br>유사배열객체(array-like object)이다.<ul>
<li>유사 배열 객체 - length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체</li>
<li>유사 배열 객체는 배열이 아니므로 배열 메소드를 사용할 경우 에러가 발생한다.</li>
<li>배열 메소드를 사용하려면 Funcion.prototype.call, function.prototype.apply 를 사용해 간접 호출해야 한다. (번거로움)</li>
<li>대응책으로 ES6부터 Rest parameter 도입</li>
</ul>
</li>
</ul>
<h3 id="2-2-caller-프로퍼티"><a href="#2-2-caller-프로퍼티" class="headerlink" title="2.2 caller 프로퍼티"></a>2.2 caller 프로퍼티</h3><ul>
<li>ECMA 스펙에 포함되지 않은 비표준 프로퍼티</li>
<li>함수 자신을 호출한 함수를 가리킨다.</li>
</ul>
<h3 id="2-3-lengh-프로퍼티"><a href="#2-3-lengh-프로퍼티" class="headerlink" title="2.3 lengh 프로퍼티"></a>2.3 lengh 프로퍼티</h3><ul>
<li>함수 정의 시 선언한 매개변수의 개수를 가리킨다.</li>
<li>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다.</li>
<li>arguments 객체의 length 프로퍼티는 인자(argument)의 개수를 가리키고,<br>함수 객체의 length 프로퍼티는 매개변수(parameter)의 개수를 가리킨다.</li>
</ul>
<h3 id="2-4-name-프로퍼티"><a href="#2-4-name-프로퍼티" class="headerlink" title="2.4 name 프로퍼티"></a>2.4 name 프로퍼티</h3><ul>
<li>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. </li>
<li>ES6에서 정식 표준이 되었다.</li>
<li>익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다.</li>
<li>ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</li>
<li>함수를 호출할 때는 <strong>함수 객체를 가리키는 변수 이름</strong>으로 호출한다.</li>
</ul>
<h3 id="2-5-proto-접근자-프로퍼티"><a href="#2-5-proto-접근자-프로퍼티" class="headerlink" title="2.5 proto 접근자 프로퍼티"></a>2.5 <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다.</li>
<li>객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</li>
<li>프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티</li>
<li>간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.</li>
</ul>
<h3 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2.6 prototype 프로퍼티"></a>2.6 prototype 프로퍼티</h3><ul>
<li>함수 객체만이 소유하는 프로퍼티</li>
<li>일반 객체에는 prototype 프로퍼티가 없다.</li>
<li>함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/03/js.constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/js.constructor/" class="post-title-link" itemprop="url">js.constructor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-03 17:31:22" itemprop="dateCreated datePublished" datetime="2020-03-03T17:31:22+09:00">2020-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-12 11:56:39" itemprop="dateModified" datetime="2020-03-12T11:56:39+09:00">2020-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><ul>
<li>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.</li>
<li>생성자(constructor) 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.</li>
<li>new 연산자와 함께 생성자 함수를 호출하지 않으면, 일반 함수로 동작한다.</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2.1 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2.1 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li>객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다.</li>
<li>동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 비효율적이다.</li>
<li>객체는 프로퍼티를 통해 객체의 고유상태를 표현,<br>메소드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작을 표현한다.</li>
</ul>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2.2 생성자 함수에 의한 객체 생성 방식의 장점"></a>2.2 생성자 함수에 의한 객체 생성 방식의 장점</h3><ul>
<li>프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);  <span class="comment">//반지름이 5인 Circle 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>);  <span class="comment">//반지름이 10인 Circle 객체 생성  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter());  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter());  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p><strong>this</strong><br>this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수<br>this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.</p>
<table>
<thead>
<tr>
<th>함수 호출방식</th>
<th align="center">this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수로서 호출</td>
<td align="center">전역 객체</td>
</tr>
<tr>
<td>메소드로서 호출</td>
<td align="center">메소드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수로서 호출</td>
<td align="center">생성자 함수가 (미래에)생성할 인스턴스</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle3 = Circle(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle3);   <span class="comment">//undefined</span></span><br><span class="line"><span class="comment">// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undifined를 반환한다.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않음 -&gt; 일반함수로 동작</li>
<li>일반함수는 반환문이 없으면 암묵적으로 undefined를 반환한다.  </li>
</ul>
<h3 id="2-3-내부-메소드-Call-Construct"><a href="#2-3-내부-메소드-Call-Construct" class="headerlink" title="2.3 내부 메소드 [[Call]], [[Construct]]"></a>2.3 내부 메소드 [[Call]], [[Construct]]</h3><ul>
<li>내부 메소드 [[Call]]을 갖는 함수 객체를 callable (호출할 수 있는 객체)</li>
<li>내부 메소드 [[Construct]]을 갖는 함수 객체를 construtor<br>(생성자로서 호출할 수 있는 객체)</li>
<li>[[Construct]]을 갖지 않는 함수 객체를 non-constructor</li>
<li>함수 객체는 반드시 callable, 그리고 constructor 일수도 있고, non-constructor일 수도 있다.</li>
</ul>
<h3 id="2-4-Constructor-와-non-construct의-구분"><a href="#2-4-Constructor-와-non-construct의-구분" class="headerlink" title="2.4 Constructor 와 non-construct의 구분"></a>2.4 Constructor 와 non-construct의 구분</h3><ul>
<li><p>자바스크립트 엔진은 함수를 생성할 때, FunctionCreate라는 추상연산을 사용한다.<br>추상연산은 ECMA 사양에서 내부 동작의 구현 알고리즘을  표현한 것이다.</p>
</li>
<li><p>추상연산은 함수 정의가 평가될 때 호출된다. </p>
</li>
<li><p>함수 정의 방식에 따라 FunctionCreate의 첫번째 매개변수 kind에 함수의 종류를 나타내는 문자열이 전달된다.</p>
<table>
<thead>
<tr>
<th>구분</th>
<th align="center">함수의 종류를 나타내는 문자열</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수 정의를 평가할 때</td>
<td align="center">Normal</td>
</tr>
<tr>
<td>화살표 함수 정의를 평가할 때</td>
<td align="center">Arrow</td>
</tr>
<tr>
<td>메소드 정의를 평가할 때</td>
<td align="center">Method</td>
</tr>
</tbody></table>
</li>
<li><p>함수로 정의된 함수만 constructor</p>
</li>
<li><p>Arrow, Method인 함수는 non- constructor</p>
</li>
<li><p>non-construtor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다.</p>
</li>
</ul>
<h3 id="2-5-생성자-함수의-인스턴스-생성-과정"><a href="#2-5-생성자-함수의-인스턴스-생성-과정" class="headerlink" title="2.5 생성자 함수의 인스턴스 생성 과정"></a>2.5 생성자 함수의 인스턴스 생성 과정</h3><ul>
<li><p>생성자 함수의 역할 - 인스턴스를 생성하는 것, 생성된 인스턴스를 초기화하는 것</p>
</li>
<li><p>인스턴스 초기화 - 인스턴스 프로퍼티 추가 및 초기값 할당</p>
</li>
<li><p>생성자 함수가 인스턴스를 생성하는 것은 필수, 초기화하는 것은 옵션</p>
</li>
<li><p>생성과정</p>
<ol>
<li>인스턴스 생성과 this 바인딩<br>암묵적으로 빈 객체가 생성된다. (생성자 함수가 생성한 인스턴스)<br>인스턴스는 this에 바인딩된다.</li>
<li>인스턴스 초기화<br>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스 초기화<br>this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값 할당</li>
<li>인스턴스 반환<br>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.<br>this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고, return문에 명시한 객체가 반환된다.<br>명시적으로 원시값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다.</li>
</ol>
<p>생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 return문을 반드시 생략해야 한다.</p>
</li>
</ul>
<h3 id="2-6-new-연산자"><a href="#2-6-new-연산자" class="headerlink" title="2.6 new 연산자"></a>2.6 new 연산자</h3><ul>
<li>new 연산자와 함께 호출하는 함수는 constructor여야 한다.</li>
<li>new 연산자 없이 생성자 함수를 호출하면 일반함수로 호출된다. [[Call]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new 연산자 없이 생성자 함수를 호출하면 일반 함수로서 호출</span></span><br><span class="line"><span class="keyword">const</span> circle = Circle(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle);    <span class="comment">//undifined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//일반 함수 내부의 this는 전역 객체 window를 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(radius);          <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(getDiameter());   <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>circle 함수를 일반적인 함수로 호출하면 함수 내부의 this는 전역 객체 window를 가리킨다. radius 프로퍼티, getDiameter 메소드는 전역 객체가 된다.</p>
<h3 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2.7 new.target"></a>2.7 new.target</h3><ul>
<li>new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해, ES6에서 new.target 지원</li>
<li>new.target은 this와 유사하게 모든 함수내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다.  IE는 지원하지 않는다.</li>
<li>함수 내부에서 new.target을 사용하면 new 연산자와 함께 함수가 호출되었는지 확인 가능</li>
<li>new 연산자 없이 호출된 함수 내부의 new.target은 undifined</li>
<li>new.target을 사용할 수 없는 상황이면 스코프 세이프 생성자 패턴을 사용</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.property/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.property/" class="post-title-link" itemprop="url">js.property</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-29 18:57:36" itemprop="dateCreated datePublished" datetime="2020-02-29T18:57:36+09:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 17:56:07" itemprop="dateModified" datetime="2020-03-10T17:56:07+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><ul>
<li>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMA 사양에서 사용하는 의사 프로퍼티와 의사 메소드 이다.  [[]]</li>
<li>외부로 공개된 객체의 프로퍼티는 아니다.</li>
<li>간접적으로만 접근할 수 있다.</li>
</ul>
<h2 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h2><p>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의</p>
<p><strong>프로퍼티 상태?</strong><br>프로퍼티의 값(value), 값의 갱신 가능여부(writable), 열거가능여부(enumberable), 재정의 가능여부(configurable)</p>
<p><strong>프로퍼티 어트리뷰트</strong></p>
<ul>
<li>자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)</li>
<li>Object.getOwnPropertyDescriptor 메소드를 이용해 간접적으로 확인할 수 있다. (직접적 불가)<ul>
<li>메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달<br>두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다.                </li>
<li>프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor)객체를 반환</li>
<li>만약 존재하지 않는 프로퍼티, 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undifined가 반환</li>
<li>ES8에 도입된 Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환</li>
</ul>
</li>
</ul>
<h2 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h2><ul>
<li>데이터 프로퍼티(date property) 키와 값으로 구성된 일반적인 프로퍼티</li>
<li>잡근자 프로퍼티(Accessor property) 자체적으로는 값을 갖지않고, 다른 데이터 프로퍼티 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티</li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3.1 데이터 프로퍼티"></a>3.1 데이터 프로퍼티</h3><p>데이터 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.</p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th align="center">프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="right">설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td align="center">vlaue</td>
<td align="right">- 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값 <br>-프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의[[Value]]에 값을 저장한다.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td align="center">writable</td>
<td align="right">- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.<br> - false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는는 읽기 전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Enumberable]]</td>
<td align="center">enumberable</td>
<td align="right">- 프로퍼티의 열거 가능여부를 나타내며 불리언 값을 갖는다.<br>- false인 경우, 해당 프로퍼티는 for…in문이나 Object.keys 메소드 등으로 열거할 수 없다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td align="center">configurable</td>
<td align="right">- 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.<br> - false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단 [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnpropertyDescriptor(person.<span class="string">'name'</span>));</span><br><span class="line"><span class="comment">// &#123; value: "Lee", wrtable: true, enumberale: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3.2 접근자 프로퍼티"></a>3.2 접근자 프로퍼티</h3><ul>
<li><p>자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.</p>
</li>
<li><p>getter, setter 함수라고도 부른다. 두 함수 모두 정의할 수 있고, 하나만 정의할 수도 있다.</p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th align="center">프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="right">설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td align="center">get</td>
<td align="right">- 데이터 프로퍼티의 값을 저장할 때 호출<br>프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, getter 함수가 호출, 그결과가 프로퍼티 값으로 반환된다.</td>
</tr>
<tr>
<td>[[Set]]</td>
<td align="center">set</td>
<td align="right">데이터 프로퍼티의 값을 저장할 때 호출<br>프로퍼티 어트리뷰트[[Set]]의 값, setter함수가 호출되고 그결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumberable]]</td>
<td align="center">enumberable</td>
<td align="right">데이터 프로퍼티의 [[Enumerable]]와 같다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td align="center">configurable</td>
<td align="right">데이터 프로퍼티의 [[Configurable]]와 같다.</td>
</tr>
</tbody></table>
</li>
</ul>
<ol>
<li>프로퍼티 키가 유효한지 확인한다. 문자열 또는 심볼이여야 한다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다.</li>
<li>검색된 프로퍼티가 데이터 프로퍼티인지, 접근자 프로퍼티인지 확인한다.</li>
<li>프로퍼티 어트리뷰트 [[Get]]. getter 함수를 호출하여 그 결과를 반환한다.</li>
</ol>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><ul>
<li>새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트릴뷰트를 재정의 하는 것</li>
<li>객체의 프로퍼티가 어떻게 동작해야 하는지 명확히 정의할 수 있다.</li>
<li>Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. </li>
<li>인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다.</li>
<li>Object.defineProperty 메소드로 프로퍼티 정의할 때, 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다.</li>
</ul>
<table>
<thead>
<tr>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="center">대응하는 프로퍼티 어트리뷰트</th>
<th align="right">디스크립터 객체의 프로퍼티 누락시 기본값</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td align="center">[[Value]]</td>
<td align="right">undifined</td>
</tr>
<tr>
<td>get</td>
<td align="center">[[Get]]</td>
<td align="right">undifined</td>
</tr>
<tr>
<td>set</td>
<td align="center">[[Set]]</td>
<td align="right">undifined</td>
</tr>
<tr>
<td>writable</td>
<td align="center">[[Writable]]</td>
<td align="right">false</td>
</tr>
<tr>
<td>enumberable</td>
<td align="center">[[Enumberable]]</td>
<td align="right">false</td>
</tr>
<tr>
<td>configurable</td>
<td align="center">[[Configurable]]</td>
<td align="right">false</td>
</tr>
</tbody></table>
<h2 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h2><ul>
<li>객체는 변경 가능한 값. 재할당 없이 직접 변경 가능</li>
<li>Object.defineProperty or Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수 도있다.</li>
<li>자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공</li>
</ul>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5.1 객체 확장 금지"></a>5.1 객체 확장 금지</h3><ul>
<li>Object.preventExtensions 메소드는 객체의 확장을 금지</li>
<li>확장이 금지된 객체는 추가가 금지된다.</li>
<li>동적추가와, 메소드로 추가  둗가지 모두 금지</li>
<li>확장금지 객체 여부는 Object.isExtensible 메소드로 확인 가능하다</li>
</ul>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5.2 객체 밀봉"></a>5.2 객체 밀봉</h3><ul>
<li>Object.seal 메소드는 객체를 밀봉</li>
<li>프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의를 금지한다.</li>
<li>밀봉된 객체는 읽기와 쓰기만 가능</li>
<li>밀봉 객체 여부는 Object.isSealed 메소드로 확인가능</li>
</ul>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5.3 객체 동결"></a>5.3 객체 동결</h3><ul>
<li>Object.freeze 메소드는 객체를 동결</li>
<li>프로퍼티 추가 삭제 금지, 재정의 금지, 갱신 금지</li>
<li>동결된 객체는 읽기만 가능</li>
<li>Object.Frozen 메소드로 확인가능</li>
</ul>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5.4 불변 객체"></a>5.4 불변 객체</h3><ul>
<li>위 메소드들은 얕은 변경방지(Shallow only) =&gt; 직속  프로퍼티에만 변경이 방지되고 중첩 객체 까지는 영향을 주지 못한다.</li>
<li>객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변객체를 구현하려면, 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.let%20const%20and%20var/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.let%20const%20and%20var/" class="post-title-link" itemprop="url">js.let const and var</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 23:50:06" itemprop="dateCreated datePublished" datetime="2020-02-28T23:50:06+09:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 17:56:33" itemprop="dateModified" datetime="2020-03-10T17:56:33+09:00">2020-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="let-const와-블록-레벨-스코프-feat-var"><a href="#let-const와-블록-레벨-스코프-feat-var" class="headerlink" title="let, const와 블록 레벨 스코프  (feat. var)"></a>let, const와 블록 레벨 스코프  (feat. var)</h1><h2 id="1-var로-선안한-변수의-문제점"><a href="#1-var로-선안한-변수의-문제점" class="headerlink" title="1. var로 선안한 변수의 문제점"></a>1. var로 선안한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1.1 변수 중복 선언 허용"></a>1.1 변수 중복 선언 허용</h3><ul>
<li>같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 자바 스크립트 엔진에 의해 var 키워드가 없는 것 처럼 동작한다.</li>
<li>먼저 선언된 변수값이 변경되는 부작용 발생</li>
<li>문법적으로 허용,  하지만 사용하지 않는 것이 좋다.</li>
</ul>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1.2 함수 레벨 스코프"></a>1.2 함수 레벨 스코프</h3><ul>
<li>오직 함수 코드블록만을 지역 스코프로 인정한다.</li>
<li>함수 외부에서 var 키워드 선언 -&gt; 전역 변수(코드 블록 내에 있더라도 for문 등등..)</li>
</ul>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1.3 변수 호이스팅"></a>1.3 변수 호이스팅</h3><ul>
<li>변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</li>
<li>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 가독성을 떨어뜨리고 오류를 발생시킬 가능성이 있다.</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><p>var 를 보안하기 위해 ES6에서 let, const 도입</p>
<h3 id="2-1-변수-중복-선언-금지"><a href="#2-1-변수-중복-선언-금지" class="headerlink" title="2.1 변수 중복 선언 금지"></a>2.1 변수 중복 선언 금지</h3><ul>
<li>let 키워드로 동일한 변수를 중복 선언하면 SyntaxError가 발생한다.</li>
</ul>
<h3 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2.2 블록 레벨 스코프"></a>2.2 블록 레벨 스코프</h3><p>let 키워드로 선언한 변수는 모든 코드블록 (함수, if, for, while, try/catch문 등)을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.  블록레벨스코프 = 지역 스코프 = 지역변수</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;          <span class="comment">// &lt;- 전역 스코프</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;     <span class="comment">// &lt;= 함수 레벨 스코프</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">3</span>; i++) &#123;     </span><br><span class="line">    <span class="built_in">console</span>.log(i);   <span class="comment">// 1, 2   &lt;= 블록 레벨 스코프</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);  <span class="comment">// 100</span></span><br><span class="line">&#125;</span><br><span class="line">foo ();</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2.3 변수 호이스팅"></a>2.3 변수 호이스팅</h3><p>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x);   <span class="comment">//ReferenceError: foo is not defined</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<ul>
<li>let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행한다 (!== var)</li>
<li>런타임 이전에 암묵적으로 선언 단계 먼저 실행(자바스크립트 엔진에 의해)</li>
<li>초기화 단계는 선언문에 도달했을 때 실행된다.</li>
<li>초기화 단계가 실행되기 이전에 변수에 접급하려고 하면 참조에러가 발생된다.</li>
<li>스코프의 시작지점부터 초기화 시작 지점까지 변수를 참조할 수 없다. (TDZ)</li>
<li>let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것 처럼 동작한다.</li>
</ul>
<h3 id="2-4-전역객체와-let"><a href="#2-4-전역객체와-let" class="headerlink" title="2.4 전역객체와 let"></a>2.4 전역객체와 let</h3><ul>
<li>let, const 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 아니다.</li>
<li>let 전역 변수는 보이지 않는 개념적인블록 내에 존재하게 된다.</li>
</ul>
<h2 id="3-1-const"><a href="#3-1-const" class="headerlink" title="3.1 const"></a>3.1 const</h2><h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3.1 선언과 초기화"></a>3.1 선언과 초기화</h3><ul>
<li>const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다.</li>
<li>그렇지 않으면 SyntaxError</li>
<li>변수 호이스팅이 발생하지 않는 것처럼 동작한다.</li>
<li>블록 레벨 스코프를 갖는다.</li>
</ul>
<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3.2 재할당 금지"></a>3.2 재할당 금지</h3><p>const로 선언한 변수 재할당 금지 (let, var 가능)</p>
<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3.3 상수"></a>3.3 상수</h3><ul>
<li>상수. 값을 저장하기 위하 메모리 공간이 필요함으로 변수라고 할 수 있다. (재할당금지)</li>
<li>상태 유지와 가독성, 유지보수의 편의를 위해 사용해야한다.</li>
</ul>
<h3 id="3-4-const와-객체"><a href="#3-4-const와-객체" class="headerlink" title="3.4 const와 객체"></a>3.4 const와 객체</h3><ul>
<li>const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다. </li>
<li>재할당을 금지할 뿐  불변을 의미하지 않는다.</li>
<li>객체의 내용이 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  age: <span class="string">'32'</span></span><br><span class="line">&#125;;</span><br><span class="line">person.name = <span class="string">'20'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);   <span class="comment">// &#123;age: '20'&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.global%20variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.global%20variable/" class="post-title-link" itemprop="url">js.global variable</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 21:03:33 / Modified: 23:18:57" itemprop="dateCreated datePublished" datetime="2020-02-27T21:03:33+09:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><p>전역 변수의 무분별한 사용은 위험하다. 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야한다.</p>
<h2 id="1-변수의-생명-주기"><a href="#1-변수의-생명-주기" class="headerlink" title="1. 변수의 생명 주기"></a>1. 변수의 생명 주기</h2><p>변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.<br>생명주기(Life cycle)이 있다.</p>
<h3 id="1-1-지역-변수의-생명-주기"><a href="#1-1-지역-변수의-생명-주기" class="headerlink" title="1.1 지역 변수의 생명 주기"></a>1.1 지역 변수의 생명 주기</h3><p>지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>지역 변수 x는 변수가 호출되기 이전까지는 생성되지 않는다.</p>
<ul>
<li>함수 내부에서 선언한 변수는 함수가 호출된 직후, 함수 몸체의 다른 코드가 실행되기 전에 자바스크립트에 의해 실행되고 undefined로 초기화된다.</li>
<li>그 후, 함수 몸체의 문들이 순차적으로 실행되고 변수 할당문이 실행되면 변수에 값이 할당된다.</li>
<li>함수가 종료하면 지역 변수도 소멸되어 생명 주기가 종료된다.</li>
<li>지역 변수 생명주기 == 함수 생명 주기</li>
</ul>
<h2 id="1-2-전역-변수의-생명-주기"><a href="#1-2-전역-변수의-생명-주기" class="headerlink" title="1.2 전역 변수의 생명 주기"></a>1.2 전역 변수의 생명 주기</h2><ul>
<li>전역 코드는 명시적 호출없이 실행된다. 코드가 로드되자마자 곧바로 해석하고 실행</li>
<li>전역 코드에는 함수처럼 return문을 사용할 수 없으므로 마지막 문이 실행 된 후, 더이상 실행할 문이 없을 때 종료한다.</li>
</ul>
<h4 id="return-문의-위치"><a href="#return-문의-위치" class="headerlink" title="return 문의 위치"></a>return 문의 위치</h4><ul>
<li><p>return문은 함수 내부에서만 사용 가능하다.</p>
</li>
<li><p>전역에서 사용하면 SyntaxError가 발생한다.</p>
</li>
<li><p>Node.js 환경에서는 파일의 가장 바깥 영역에 return문을 사용해도 에러가 발생하지 않는다. 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갖기 때문이다.</p>
</li>
<li><p>var 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 된다.<br>전역 변수의 생명주기 == 전역 객체의 생명 주기</p>
</li>
</ul>
<h4 id="전역-객체-Global-Object"><a href="#전역-객체-Global-Object" class="headerlink" title="전역 객체(Global Object)"></a>전역 객체(Global Object)</h4><ul>
<li>코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 생성되는  특수한 객체이다.</li>
<li>클라이언트 사이드 환경(브라우저) <strong>window</strong></li>
<li>서버 사이드 환경(Node.js) <strong>global객체</strong></li>
<li>전역 객체에는 표준 빌트인 객체, 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.<br>
표준 빌트인 객체(Object, String, Number, Function, Array 등)
호스트 객체(클라이언트 web API, Node.js의 호스트 API)

</li>
</ul>
<h2 id="2-전역-변수의-문제점"><a href="#2-전역-변수의-문제점" class="headerlink" title="2. 전역 변수의 문제점"></a>2. 전역 변수의 문제점</h2><h3 id="암묵적-결합"><a href="#암묵적-결합" class="headerlink" title="암묵적 결합"></a>암묵적 결합</h3><ul>
<li>전역 변수를 선언한 의도는 어디에서든지 전역 변수를 사용하겠다는 것이다. </li>
<li>모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것이다.</li>
<li>변수의 유효범위가 클수록 코드의 가독성은 나빠지고, 의도치 않게 상태가 변경될 수 있는 위험성 또한 높아진다.</li>
</ul>
<h3 id="긴-생명-주기"><a href="#긴-생명-주기" class="headerlink" title="긴 생명 주기"></a>긴 생명 주기</h3><p>전역 변수는 생명 주기가 길다.  </p>
<ul>
<li>메모리 리소스도 오랜기간 소비한다.</li>
<li>전역 변수의 상태를 변경할 수 있는 시간도 길고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다.</li>
<li>var 키워드는 변수의 중복 선언을 허용하므로, 변수 이름이 중복될 가능성이 있다.  (의도치 않는 재할당)</li>
</ul>
<h3 id="스코프-체인-상에서-종점에-존재"><a href="#스코프-체인-상에서-종점에-존재" class="headerlink" title="스코프 체인 상에서 종점에 존재"></a>스코프 체인 상에서 종점에 존재</h3><p>변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다. 전역 변수의 검색속도가 가장 느리다.</p>
<h3 id="네임-스페이스-오염"><a href="#네임-스페이스-오염" class="headerlink" title="네임 스페이스 오염"></a>네임 스페이스 오염</h3><p>파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.<br>다른 파일 내에서 동일한 이름으로 생성된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</p>
<h2 id="3-전역-변수-사용-억제-방법"><a href="#3-전역-변수-사용-억제-방법" class="headerlink" title="3. 전역 변수 사용 억제 방법"></a>3. 전역 변수 사용 억제 방법</h2><p>전역 변수를 반드시 사용할 이유가 없다면 지역 변수를 사용해야한다. 변수의 스코프는 좁을수록, 빨리 소멸될 수록 좋다.</p>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3.1 즉시 실행 함수"></a>3.1 즉시 실행 함수</h3><p>함수의 정의와 동시에 단 한번 만 호출된다.<br>함수 내의 지역 변수는 바로 소멸된다.<br>이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다.</p>
<h3 id="3-2-네임-스페이스-객체"><a href="#3-2-네임-스페이스-객체" class="headerlink" title="3.2 네임 스페이스 객체"></a>3.2 네임 스페이스 객체</h3><ul>
<li>전역에 네임스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;   <span class="comment">//  네임 스페이스 객체 (전역)</span></span><br><span class="line"></span><br><span class="line">MYAPP.name = <span class="string">'Lee'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.name); <span class="comment">//Lee</span></span><br></pre></td></tr></table></figure>
<ul>
<li>네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;   <span class="comment">//  네임 스페이스 객체 (전역)</span></span><br><span class="line"></span><br><span class="line">MYAPP.person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span>,</span><br><span class="line">  address: <span class="string">'Seoul'</span>      <span class="comment">//네임 스페이스 계층</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(MYAPP.person.name); <span class="comment">//Lee</span></span><br></pre></td></tr></table></figure>

<p>네임 스페이스를 분리하여 식별자 충돌을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역 변수에 해당되므로 그다지 유용해 보이지는 않는다.</p>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3.3 모듈 패턴"></a>3.3 모듈 패턴</h3><p>모듈 패턴은 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 클로저를 기반으로 동작한다.<br><strong>모듈 패턴의 특징</strong></p>
<ul>
<li>전역 변수의 억제</li>
<li>캡슐화 구현 (캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉이라고도 한다.)</li>
<li>모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능은 한정적.<br>캡슐화를 구현하기 위해 사용한다.</li>
</ul>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3.4 ES6 모듈"></a>3.4 ES6 모듈</h3><p>전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다.<br>script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"lib.mjs"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>모던 브라우저에만 동작,  IE를 포함한 구형 브라우저에는 동작하지 않는다.</li>
<li>브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에, 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. </li>
</ul>
<br>
<br>
새로운 개념.. 네임 스페이스, 모듈패턴, 트랜스 파일링, 번들링 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.function/" class="post-title-link" itemprop="url">js.function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 00:07:49 / Modified: 02:06:42" itemprop="dateCreated datePublished" datetime="2020-02-27T00:07:49+09:00">2020-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수"><a href="#함수" class="headerlink" title="함수"></a>함수</h1><h2 id="1-함수란"><a href="#1-함수란" class="headerlink" title="1. 함수란?"></a>1. 함수란?</h2><p>input을 받아서 output을 내보내는 일련의 과정<br>함수는 함수 정의(Function definition)를 통해 생성한다.<br>JS의 함수는 다양한 방법으로 정의할 수 있다.<br>함수의 정의만으로 함수가 실행되지 않는다. 인수 -&gt; 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시해야한다. <br>이를 함수호출(Function call/invoke)이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f(x, y) = x + y</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;  <span class="comment">//함수 정의</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>);   <span class="comment">//7     //함수 호출</span></span><br></pre></td></tr></table></figure>
<p>함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 반환값을 반환한다.</p>
<h2 id="2-함수의-사용-이유"><a href="#2-함수의-사용-이유" class="headerlink" title="2. 함수의 사용 이유"></a>2. 함수의 사용 이유</h2><ul>
<li>동일한 작업을 반복적으로 수행한다면, 미리 정의된 함수를 재사용하는 것이 효율적이다.<br>함수는 얼마든지 호출할 수 있으므로 코드의 재사용의 측면에서 매우 유용하다.</li>
<li>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</li>
<li>코드의 가독성을 향상시킨다. (객체타입의 값이라 식별자를 붙일 수 있음)</li>
</ul>
<h2 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h2><p>JS의 함수는 <strong>객체 타입의 값</strong><br>함수 리터럴은 function 키워드, 함수 이름, 매개변수, 함수 몸체로 구성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 변수에 함수 리터럴을 할당</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>함수는 호출할 수 있지만, 일반 객체는 호출할 수 없다.<br><br>함수 객체만의 고유한 프로퍼티를 갖는다.</p>
<h4 id="함수이름"><a href="#함수이름" class="headerlink" title="함수이름"></a>함수이름</h4><ul>
<li>함수 이름은 식별자. 네이밍 규칙을 준수해야한다.</li>
<li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다.</li>
<li>함수 이름은 생략 가능하다.</li>
</ul>
<h4 id="매개변수-목록"><a href="#매개변수-목록" class="headerlink" title="매개변수 목록"></a>매개변수 목록</h4><ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.</li>
<li>함수 호출문의 인수가 순서대로 할당된다. 매개변수 목록은 순서에 의미가 있다.</li>
<li>함수 몸체 내에서 변수와 동일하게 취급된다. 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야한다.</li>
</ul>
<h4 id="함수-몸체"><a href="#함수-몸체" class="headerlink" title="함수 몸체"></a>함수 몸체</h4><ul>
<li>함수 몸체는 함수 호출에 의해 실행된다.</li>
<li>함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.</li>
</ul>
<h2 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h2><p>함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//function 생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x + y'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//화살표 함수 (ES6에 추가)</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-함수-선언문"><a href="#4-1-함수-선언문" class="headerlink" title="4.1 함수 선언문"></a>4.1 함수 선언문</h3><ul>
<li>함수 선언문은 리터럴과 형태가 동일하다. 함수 선언문은 함수 이름을 생략할 수 없다.</li>
<li>함수 선언문은 표현식이 아닌 문이다. (선언문이기 때문에 undefined를 출력한다.)</li>
<li>표현식이 아닌 문은 변수에 할당할 수 없지만, <strong>함수 선언문은 변수에 할당하는 것 처럼 보인다.</strong></li>
<li>JS 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.</li>
<li>함수는 함수 이름으로 호출하는게 아니라 함수 객체를 가리키는 식별자로 호출한다.</li>
</ul>
<p><strong>자바스크립트 엔진은 함수선언문을 함수 표현식으로 변환하여 함수 객체를 생성한다고 생각할 수 있다.</strong></p>
<h3 id="4-2-함수-표현식"><a href="#4-2-함수-표현식" class="headerlink" title="4.2 함수 표현식"></a>4.2 함수 표현식</h3><ul>
<li><p>자바스크립트의 함수는 일급 객체  (함수를 값처럼 자유롭게 사용할 수 있음)</p>
</li>
<li><p>일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다.</p>
</li>
<li><p>함수 리터럴의 함수 이름은 생략할 수 있다. (생략하는 것이 일반적, 익명 함수)</p>
<p>함수 선언문과 함수 표현식의 차이.  함수 생성 시점과 호이스팅</p>
</li>
</ul>
<h3 id="4-3-함수-생성-시점과-함수-호이스팅"><a href="#4-3-함수-생성-시점과-함수-호이스팅" class="headerlink" title="4.3 함수 생성 시점과 함수 호이스팅"></a>4.3 함수 생성 시점과 함수 호이스팅</h3><p>함수 선언문과 함수 표현식은 함수 생성 시점이 다르다.  </p>
<ul>
<li>함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.<br>자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당</li>
<li>함수 선언문을 통해 암묵적으로 생성된 식별자는 <strong>함수 객체로 초기화</strong></li>
</ul>
<p>함수 표현식은 변수 할당문의 값이 함수 리터럴인 문</p>
<ul>
<li>함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다.</li>
<li>변수 할당문의 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</li>
<li>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 <strong>변수 호이스팅이 발생한다.</strong></li>
<li>함수 표현식 이전에 함수를 참조하면 타입에러가 발생한다. </li>
<li>함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.</li>
</ul>
<h3 id="4-4-Function-생성자-함수-빌트인-함수-Constructor-Function"><a href="#4-4-Function-생성자-함수-빌트인-함수-Constructor-Function" class="headerlink" title="4.4 Function 생성자 함수 (빌트인 함수) (Constructor Function)"></a>4.4 Function 생성자 함수 (빌트인 함수) (Constructor Function)</h3><ul>
<li>생성자 함수는 객체를 생성하는 함수.</li>
<li>Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.</li>
</ul>
<h3 id="4-5-화살표-함수"><a href="#4-5-화살표-함수" class="headerlink" title="4.5 화살표 함수"></a>4.5 화살표 함수</h3><ul>
<li>화살표 함수는 항상 익명 함수로 정의한다.</li>
<li>생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.</li>
</ul>
<h2 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h2><ul>
<li>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.</li>
<li>함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다.</li>
<li>호출하면 현재의 실행 흐름을 중단, 호출된 함수로 컨트롤을 넘긴다.<br>인수 -&gt; 매개변수 할당 , 함수 몸체의 문들이 실행</li>
</ul>
<h3 id="5-1-매개변수와-인수"><a href="#5-1-매개변수와-인수" class="headerlink" title="5.1 매개변수와 인수"></a>5.1 매개변수와 인수</h3><p>함수 외부에서 함수 내부로 필요 값을 전달할 필요가 있는 경우  인수(외부) -&gt; 매개변수(내부)</p>
<ul>
<li>인수는 값으로 평가될 수 있는 표현식이어야 하며, 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다.</li>
<li>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급한다.<br>(함수가 호출되면 함수 몸체 내에 암묵적으로 매개변수가 생성되고, undefined로 초기화된 이후 인수가 순서대로 할당된다.)  호출될 때마다 이 단계를 거침</li>
<li>매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.<br>(스코프는 함수 내부이다.)</li>
<li>매개변수와 인수의 개수를 체크하지 않는다. <ul>
<li>인수가 부족하면 할당되지 않은 매개변수의 값은 undefined</li>
<li>초과된 인수는 무시된다. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.</li>
</ul>
</li>
</ul>
<h3 id="5-2-인수-확인"><a href="#5-2-인수-확인" class="headerlink" title="5.2 인수 확인"></a>5.2 인수 확인</h3><ul>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.<br>따라서 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요하다.</li>
</ul>
<h3 id="5-3-매개변수의-최대-개수"><a href="#5-3-매개변수의-최대-개수" class="headerlink" title="5.3 매개변수의 최대 개수"></a>5.3 매개변수의 최대 개수</h3><ul>
<li>이상적인 매개변수 개수는 0개이며 적을 수록 좋다. </li>
<li>3개 이상을 넘지 않는 것을 권장한다. (그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다.)</li>
<li>매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 변경되므로 함수를 사용하는 코드 전체가 영향을 받는다.  (유지보수성도 나빠진다.)</li>
</ul>
<h3 id="5-4-반환문"><a href="#5-4-반환문" class="headerlink" title="5.4 반환문"></a>5.4 반환문</h3><ul>
<li>실행 결과를 함수 외부로 반환(return)</li>
<li>반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.</li>
<li>반환문 이후에 다른 문이 존재하면 그 문은 무시된다.</li>
<li>return 키워드 뒤에 지정한 값을 반환한다. 명시적을 지정하지 않으면 undefined가 반환된다.</li>
<li>반환문을 생략할 수 있다. 함수는 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.</li>
</ul>
<h2 id="6-참조에-의한-전달과-외부-상태의-변경"><a href="#6-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="6. 참조에 의한 전달과 외부 상태의 변경"></a>6. 참조에 의한 전달과 외부 상태의 변경</h2><p>함수의 매개변수에 값을 전달하는 방식 <strong>Call by value, Call by reference</strong><br>동작 방식은 <strong>값에 의한 전달, 참조에 의한 전달</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//primitive은 원시값, obj는 객체를 전달받는다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeVal</span>(<span class="params">primitive, obj</span>) </span>&#123;</span><br><span class="line">  primitive += <span class="number">100</span>;</span><br><span class="line">  obj.name = <span class="string">'Kim'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//외부 상태</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">'Jung'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: 'Jung'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달</span></span><br><span class="line">changeVal(num, person);</span><br></pre></td></tr></table></figure>
<p>원시 값은 원본이 훼손되지 않는다. 객체는 원본이 훼손된다.</p>
<ul>
<li>원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 원본은 훼손되지 않는다. side-effect가 없다</li>
<li>객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 원본이 훼손된다. side-effect 발생</li>
<li>객체를 불변 객체로 만들어 사용해서 외부상태가 변경되는 side-effect를 없앨 수 있다.</li>
</ul>
<h2 id="7-다양한-함수의-형태"><a href="#7-다양한-함수의-형태" class="headerlink" title="7. 다양한 함수의 형태"></a>7. 다양한 함수의 형태</h2><h3 id="7-1-즉시실행함수-IIFE"><a href="#7-1-즉시실행함수-IIFE" class="headerlink" title="7.1 즉시실행함수(IIFE)"></a>7.1 즉시실행함수(IIFE)</h3><ul>
<li>즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다. (첫번째 메인 페이지에 사용)</li>
<li>익명 함수를 사용하는 것이 일반적이다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
<li>즉시 실행 함수는 반드시 그룹 연산자()로 감싸 주어야 한다.</li>
<li>그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다.</li>
</ul>
<h3 id="7-2-재귀-함수-recursive-function"><a href="#7-2-재귀-함수-recursive-function" class="headerlink" title="7.2 재귀 함수(recursive function)"></a>7.2 재귀 함수(recursive function)</h3><ul>
<li>함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다.</li>
<li>팩토리얼은 재귀 호출로 간단히 구현할 수 있다.</li>
<li>재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.</li>
<li>함수 호출은 반드시 함수를 가리키는 식별자로 해야 한다.</li>
<li>재귀 함수는 for 문이나 while 문으로 구현 가능하다.</li>
</ul>
<h3 id="7-3-중첩-함수-nested-function"><a href="#7-3-중첩-함수-nested-function" class="headerlink" title="7.3 중첩 함수(nested function)"></a>7.3 중첩 함수(nested function)</h3><ul>
<li>함수 내부에 정의된 함수를 중첩함수 또는 내부 함수(inner function)라 한다.</li>
<li>중첩 함수를 포함하는 함수를 외부 함수(outer function)라 한다.</li>
<li>일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할을 한다.</li>
</ul>
<h3 id="7-4-콜백-함수-Callback-function"><a href="#7-4-콜백-함수-Callback-function" class="headerlink" title="7.4 콜백 함수(Callback function)"></a>7.4 콜백 함수(Callback function)</h3><p>고차함수(Higher-Order Function, HOF)의 인자로 넘겨지는 함수.<br>콜백 함수는 고차함수 내에서 수행된다.   (내용 추가하기)</p>
<h3 id="7-5-순수-함수와-비순수-함수"><a href="#7-5-순수-함수와-비순수-함수" class="headerlink" title="7.5 순수 함수와 비순수 함수"></a>7.5 순수 함수와 비순수 함수</h3><p>순수 함수 - 부수효과가 없는 함수(외부 상태를 변경시키는)<br>비순수 함수 - 부수효과가 있는 함수<br>함수형 프로그래밍은 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.scope/" class="post-title-link" itemprop="url">js.scope</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 16:36:31 / Modified: 18:18:19" itemprop="dateCreated datePublished" datetime="2020-02-26T16:36:31+09:00">2020-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><p>스코프는 변수, 함수와 관련있다. 스코프는 식별자가 유효한 범위를 말한다.</p>
<p><strong>함수</strong>의 매개변수는 함수 몸체 내부에서만 참조할 수 있고, 함수 몸체 외부에서는 참조할 수 없다.<br>매개변수의 스포크가 함수 몸체 내부로 한정되기 때문이다.</p>
<p><strong>변수</strong>는 코드의 가장 바깥영역(window)뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언할 수 있다. 코드 블록이나 함수는 중첩될 수 있다.<br>변수는 자신이 선언된 위치에 의해 자신이 유효한 범위(다른 코드가 변수 자신을 참조할 수 있는 범위)가 결정된다.<br>이를 스코프라 한다.</p>
<p>프로그래밍 언어에서 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다. 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.</p>
<h2 id="스코프의-종류"><a href="#스코프의-종류" class="headerlink" title="스코프의 종류"></a>스코프의 종류</h2><p>코드는 전역(global)과 지역(local)으로 구분할 수 있다.</p>
<p>이때 변수는 자신이 선언된 위치(전역 or 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다.</p>
<p><strong>전역</strong>이란 코드의 가장 바깥쪽 영역(global)을 말한다.<br>전역은 전역 스코프를 만들고, 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 전역 변수는 어디서든 참조할 수 있다.</p>
<p><strong>지역</strong>이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만들고, 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.<br>지역 변수는 자신이 선언된 지역과 하위 지역(중첩함수)에서만 참조할 수 있다.</p>
<h2 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h2><p>함수의 중첩 - 함수 몸체 내부에서 함수가 정의된 것<br>중첩 함수(nested function) - 함수 몸체 내부에서 정의한 함수<br>외부 함수(outer function) - 중첩 함수를 포함하는 함수</p>
<ul>
<li>함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.<br>중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부함수의 지역 스코프와 계층적 구조를 갖는다.</li>
<li>변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.<br><strong>지역 -&gt; 전역</strong></li>
</ul>
<p><strong>렉시컬 환경(Lexical Environment)</strong><br>스코프 체인은 실행 컨택스트(Execution Contxt)의 렉시컬 환경(Lexical Environment)을 단방향으로 연결한 것이다.<br>전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다.</p>
<h3 id="스코프-체인에-의한-변수-검색"><a href="#스코프-체인에-의한-변수-검색" class="headerlink" title="스코프 체인에 의한 변수 검색"></a>스코프 체인에 의한 변수 검색</h3><p>상위 스코프에서 유효한 변수는 하위스코프에서 참조할 수 있지만,<br>하위 스코프에서 유효한 변수를 상위스코프에서 참조할 수 없다.</p>
<h2 id="함수-레벨-스코프"><a href="#함수-레벨-스코프" class="headerlink" title="함수 레벨 스코프"></a>함수 레벨 스코프</h2><p>코드블록 아닌 함수에 의해서만 지역 스코프가 생성된다.</p>
<ul>
<li><p>블록 레벨 스코프(Block level scope)<br>모든 코드블록이 지역 스코프를 만든다.<br>let, const (ES6)</p>
</li>
<li><p>함수 레벨 스코프(Function level scope)<br>var 키워드로 선언된 변수는 오로지 함수이 코드 블록 만을 지역 스코프로 인정한다.</p>
</li>
</ul>
<h2 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  B();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();  <span class="comment">//?</span></span><br><span class="line">B();  <span class="comment">//?</span></span><br></pre></td></tr></table></figure>
<p>함수 B의 상위 스코프가 무엇인지에 따라 결정된다.</p>
<ul>
<li><p>함수를 어디서 <strong>호출</strong>했는지에 따라 함수의 상위 스코프를 결정한다.</p>
<ul>
<li>함수 B의 상위 스코프는 함수 A와 전역</li>
<li>동적 스코프(Dynamic scope) 함수 정의 시점에는 함수가 어디서 호출될지 알 수 없다. 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.</li>
</ul>
</li>
<li><p>함수를 어디서 <strong>정의</strong>했는지에 따라 함수의 상위 스코프를 결정한다.</p>
<ul>
<li>함수 B의 상위 스코프는 전역</li>
<li>렉시컬 스코프(Lexical scope), 정적스코프(Static scope) 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다. <strong>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.</strong></li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.object%20literal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.object%20literal/" class="post-title-link" itemprop="url">js.object literal</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 23:48:25" itemprop="dateCreated datePublished" datetime="2020-02-24T23:48:25+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-25 18:44:10" itemprop="dateModified" datetime="2020-02-25T18:44:10+09:00">2020-02-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="객체란"><a href="#객체란" class="headerlink" title="객체란?"></a>객체란?</h2><ul>
<li><p>자바스크립트는 객체기반의 프로그래밍 언어, 원시 값을 제외한 나머지 모든 값들이 객체이다.</p>
</li>
<li><p>원시 값이랑 반대로 객체는 변경 가능한 값이다.</p>
</li>
<li><p>객체는 키(key) 값(value)로 구성된 프로퍼티(Property)들의 집합</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">'Lee'</span>   <span class="comment">//  프로퍼티</span></span><br><span class="line">  age : <span class="number">20</span>   <span class="comment">//  프로퍼티</span></span><br><span class="line">  <span class="comment">//name, age 프로퍼티 키 / 'Lee' 20 프로퍼티 값</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>프로퍼티 값으로 함수를 사용할 수도 있다.</p>
</li>
<li><p>프로퍼티 값이 함수일 경우, 메소드(Method)라 부른다.</p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값</li>
<li>메소드: 프로퍼티를 참조하고 조작할 수 있는 동작</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">  num: <span class="number">0</span>,                    <span class="comment">//프로퍼티</span></span><br><span class="line">  increase: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      <span class="comment">//메소드</span></span><br><span class="line">    <span class="keyword">this</span>.num++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="객체-리터럴에-의한-객체-생성"><a href="#객체-리터럴에-의한-객체-생성" class="headerlink" title="객체 리터럴에 의한 객체 생성"></a>객체 리터럴에 의한 객체 생성</h2><p>자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다.<br>(<strong>객체 리터럴</strong>, Object 생성자 함수, 생성자 함수, Object.create메소드, 클래스(ES6) )</p>
<ul>
<li>객체리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다.</li>
<li>변수에 할당이 이루어지는 시점에 엔진은 객체리터럴을 해석하여 객체를 생성한다.</li>
<li>중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다.</li>
<li>객체 리터럴은 값으로 평가되는 표현식이다.</li>
<li>객체 리터럴에 프로퍼티를 포함시켜 객체의 생성과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수 있다.</li>
</ul>
<h3 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h3><p>키(key) + 값(value) = 프로퍼티<br>프로퍼티의 집합 = 객체</p>
<ul>
<li>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값</li>
<li>프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값<br>프로퍼티 갑셍 접근할 수 있는 이름으로 식별자 역할을 한다.</li>
<li>식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다.</li>
<li>프로퍼티 키에 문자열이나 symbol 값 이외의 값을 사용하면 암묵적 타입변환을 통해 문자열이 된다.</li>
<li>프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 덮어쓴다. 에러는 발생하지 않는다.</li>
</ul>
<h3 id="메소드"><a href="#메소드" class="headerlink" title="메소드"></a>메소드</h3><p>자바스크립트에서 사용할 수 있는 모든 값을 프로퍼티 값으로 사용할 수 있다.<br>프로퍼티 값이 함수일 경우, 일반함수와 구분하기 위해 메소드라 부른다. </p>
<h3 id="프로퍼티-접근"><a href="#프로퍼티-접근" class="headerlink" title="프로퍼티 접근"></a>프로퍼티 접근</h3><ul>
<li>프로퍼티 값에 접근하려면 마침표 표기법(Dot notation) 또는 대괄호 표기법(Bracket notation)을 사용한다.</li>
<li>대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이여야 한다. 단 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 생략가능</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">'Jung'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//마침표 표기법에 의한 프로퍼티 접근</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name);   <span class="comment">//Jung</span></span><br><span class="line"><span class="comment">//대괄호 표기법에 의한 프로퍼티 접근 , 대괄호 내 프로퍼티 키는 반드시 따옴표로 감싼 문자열이여야 함</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>])  <span class="comment">//Jung</span></span><br></pre></td></tr></table></figure>
<p>객체에 존재하지 않는 프로퍼티에 접근하면 <strong>undefined</strong> 반환</p>
<h3 id="프로퍼티-동적-생성"><a href="#프로퍼티-동적-생성" class="headerlink" title="프로퍼티 동적 생성"></a>프로퍼티 동적 생성</h3><p>존재하지 않는 <strong>프로퍼티에 값</strong>을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</p>
<h3 id="프로퍼티-삭제"><a href="#프로퍼티-삭제" class="headerlink" title="프로퍼티 삭제"></a>프로퍼티 삭제</h3><p>delete 연산자는 객체의 프로퍼티를 삭제한다.<br>delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이여야 한다.</p>
<h2 id="객체-리터럴의-확장-기능-ES6"><a href="#객체-리터럴의-확장-기능-ES6" class="headerlink" title="객체 리터럴의 확장 기능(ES6)"></a>객체 리터럴의 확장 기능(ES6)</h2><h3 id="프로퍼티-축약-표현"><a href="#프로퍼티-축약-표현" class="headerlink" title="프로퍼티 축약 표현"></a>프로퍼티 축약 표현</h3><p>프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.<br>변수 이름과 프로퍼티 키가 동일한 이름일 떄, 생략가능</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;x, y&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123;x:1 , y:2&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="프로퍼티-키-동적-생성"><a href="#프로퍼티-키-동적-생성" class="headerlink" title="프로퍼티 키 동적 생성"></a>프로퍼티 키 동적 생성</h3><p>ES6에서는 객체 리터럴 내부에도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.</p>
<h3 id="메소드-축약-표현"><a href="#메소드-축약-표현" class="headerlink" title="메소드 축약 표현"></a>메소드 축약 표현</h3><p>ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당<br>ES6에서는 메소드를 정의할 때, <strong>function 키워드를 생략</strong>한 축약 표현 사용 가능</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hodeng28.github.io/2020/02/js.typeCasting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hodeng28">
      <meta itemprop="description" content="헤헤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hodeng">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/js.typeCasting/" class="post-title-link" itemprop="url">js.typeCasting</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-24 21:42:00" itemprop="dateCreated datePublished" datetime="2020-02-24T21:42:00+09:00">2020-02-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-25 18:44:21" itemprop="dateModified" datetime="2020-02-25T18:44:21+09:00">2020-02-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="타입변환이란"><a href="#타입변환이란" class="headerlink" title="타입변환이란?"></a>타입변환이란?</h1><p><strong>명시적 타입 변환(Explicit coercion), 타입캐스팅(Type casting)</strong><br>개발자가 의도적으로 값의 타입을 변환</p>
<p><strong>암묵적 타입 변환(Implicit coercion), 타입 강제 변환(Type coercion)</strong><br>자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환</p>
<p>두 타입변환이 기존 원시값을 직접 변경하는 것은 아니다. (원시값은 변경 불가능한 값이므로 변경할 수 없음)<br>타입변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.</p>
<h2 id="암묵적-타입-변환"><a href="#암묵적-타입-변환" class="headerlink" title="암묵적 타입 변환"></a>암묵적 타입 변환</h2><h3 id="1-문자열-타입으로-변환"><a href="#1-문자열-타입으로-변환" class="headerlink" title="1. 문자열 타입으로 변환"></a>1. 문자열 타입으로 변환</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'2'</span>    <span class="comment">//"12"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>+연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다.</li>
<li>문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다.</li>
</ul>
<h3 id="2-숫자-타입으로-변환"><a href="#2-숫자-타입으로-변환" class="headerlink" title="2. 숫자 타입으로 변환"></a>2. 숫자 타입으로 변환</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span>   <span class="comment">// 0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span>  <span class="comment">// 10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p><strong>산술 연산자</strong>의 역할은 숫자 값을 만드는 것이다.<br>이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> &gt; <span class="number">0</span>  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><strong>비교 연산자</strong>의 역할은 불리언 값을 만드는 것이다.<br>코드의 문맥상 모두 숫자 타입이어야 한다.</p>
<h3 id="3-불리언-타입으로-변환"><a href="#3-불리언-타입으로-변환" class="headerlink" title="3. 불리언 타입으로 변환"></a>3. 불리언 타입으로 변환</h3><p>if 문이나 for 문 같은 제어문은, 또는 삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다.<br>자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) 또는 Falsy 값 (거짓으로 평가되는 값)으로 구분<br>Truthy -&gt; true, Falsy -&gt; false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Falsy 값</span><br><span class="line">false   undefined   null   0, -0   NaN   (빈문자열)</span><br></pre></td></tr></table></figure>
<p>이외의 모든 값은 모두 true로 평가되는 Truthy 값</p>
<h2 id="명시적-타입-변환"><a href="#명시적-타입-변환" class="headerlink" title="명시적 타입 변환"></a>명시적 타입 변환</h2><p>표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법<br>빌트인 메소드를 사용하는 방법</p>
<h3 id="1-문자열-타입으로-변환-1"><a href="#1-문자열-타입으로-변환-1" class="headerlink" title="1. 문자열 타입으로 변환"></a>1. 문자열 타입으로 변환</h3><ul>
<li>String 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>Object.prototype.toString 메소드를 사용하는 방법</li>
<li>문자열 연결 연산자를 이용하는 방법</li>
</ul>
<h3 id="2-숫자-타입으로-변환-1"><a href="#2-숫자-타입으로-변환-1" class="headerlink" title="2. 숫자 타입으로 변환"></a>2. 숫자 타입으로 변환</h3><ul>
<li>Number 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>parselnt, parseFloat 함수를 사용하는 방법 (문자열만 숫자 타입으로 변환 가능)</li>
<li>+단항 산술 연산자를 이용하는 방법</li>
<li>*산술 연산자를 이용하는 방법</li>
</ul>
<h3 id="3-불리언-타입으로-변환-1"><a href="#3-불리언-타입으로-변환-1" class="headerlink" title="3. 불리언 타입으로 변환"></a>3. 불리언 타입으로 변환</h3><ul>
<li>Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</li>
<li>!부정 논리 연산자를 두번 사용하는 방법</li>
</ul>
<h1 id="단축-평가"><a href="#단축-평가" class="headerlink" title="단축 평가"></a>단축 평가</h1><p>논리곱(&amp;&amp;)연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환<br>논리합(||)연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환</p>
<p>논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환<br>이를 단축 평가 (Short-Circuit evaluation)라 부른다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hodeng28</p>
  <div class="site-description" itemprop="description">헤헤</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hodeng28</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
