{"pages":[],"posts":[{"title":"React/React.state","text":"컴퓨넌트의 상태(state)가 변하면, 컴포넌트의 리렌더링을 발생시킨다.","link":"/2020/05/React/React.state/"},{"title":"React/React.props","text":"","link":"/2020/05/React/React.props/"},{"title":"javaScript/js.Asynchronous","text":"비동기 프로그래밍동기식 처리 모델(Synchronous processing model) 태스크를 순차적으로 하나씩 처리하는 방식 현재 실행중인 태스크가 종료할 때까지 다음 실행될 태스크가 대기하는 방식 앞선 태스크가 종료할 때 까지 이후 태스크들이 블로킹된다는 단점 비동기식 처리모델(Asynchronous processing model) 현재 실행중인 태스크가 종료되지 않은 상태라 하더라도 다음 태스크를 곧바로 실행하는 방식 setTimeout은 일정 시간 경과한 후에 콜백 함수를 호출하지만 이후 태스크들을 블로킹하지 않고 곧바로 실행 타이머 함수, Ajax 요청, 이벤트 처리는 비동기식 처리모델 1234567891011function foo() { console.log('foo');}function bar() { console.log('bar');}setTimeout(foo, 3 * 1000);bar();// bar -&gt;(3초 경과후) foo","link":"/2020/04/javaScript/js.Asynchronous/"},{"title":"javaScript/js.Control flow statement","text":"제어문 제어문은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있다. 1. 블록문 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부른다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 단독으로 사용할 수 있으나, 일반적으로 제어문이나 함수를 정의 할때 사용한다. 블록문의 끝에는 세미콜론을 붙이지 않는다. 2. 조건문 조건문은 주어진 조건식의 평가 결과에 따라 코드블록(블록문)의 실행을 결정한다. 불리언 값으로 평가될 수 있는 표현식이다. if..else 문은 논리적 참, 거짓으로 실행 코드 블록을 결정 switch 문은 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. if… else 문 주어진 조건식(불리언 값으로 평가 될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 평가 결과가 true일 경우, if문 다음의 코드 블록이 실행되고, false 경우 else 문 다음의 코드 블록이 실행된다. 조건식 추가 가능 else if문 여러번 사용할 수 있다. if문과 else 문은 2번 이상 사용할 수 없다. if..else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다. 1234567if (조건식1) { //true 일때 이 코드 블록이 실행} else if (조건식2) { // 조건식 추가 (else if)} else { //false 일떄(조건식1, 2 모두 거짓) 이 코드 블록이 실행} switch 문 switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. case 문은 상황을 의미하는 표현식을 지정하고 콜론으로 마친다. 그 뒤에 실행할 문들을 위치시킨다. switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동한다. switch 문의 표현식을 문자열, 숫자 값인 경우가 많다. break 키워드로 구성된 break 문은 코드 블록에서 탈출하는 역할을 한다.(default문에서는 필요없음) 12345678910switch (표현식) { case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행 될 문; } 3. 반복문 반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때 까지 반복된다. for 문 for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. for 문의 변수 선언문, 조건식, 증감식은 모두 옵션이므로 반드시 사용할 필요는 없다. 어떤 식도 선언하지 않으면 무한 루프가 된다. for문 내에 for문을 중첩해 사용할 수 있다. 1234567for (변수 선언문 or 할당문; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문;}for (var i = 0; i &lt; 2; i++) { console.log(i);} while 문 while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 가제 변환되어 논리적 참, 거짓을 구별한다. 조건식의 평가 결과가 언제나 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 코드블록 내에 if 문으로 탈출 조건을 만들고 break 문으로 코드 블록을 탈출한다. 12345678var count = 0;// count 가 5보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 5) { console.log(count); count++;}// 0 ~ 5 1234567var count = 0;while (true) { //조건식의 평가 결과가 언제나 참이면 무한루프 console.log(count); count++;if (count === 3) break; //count가 3이면 코드 블록 탈출} // 0 1 2 do.. while 문 do.. while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다. break 문 레이블 문, 반복문, switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError가 발생한다. 레이블 문 레이블 문(Label statement)는 식별자가 붙은 문을 말한다. 레이블 문은 프로그램의 실행 순서를 제어하기 위해 사용한다. switch 문의 case 문과 default 문도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다. continue 문 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지 않는다.","link":"/2020/02/javaScript/js.Control%20flow%20statement/"},{"title":"javaScript/js.Destructuring","text":"디스트럭처링 할당(Destructuring assignment, 구조 분해 할당)디스트럭처링 할당은 구조화된 배열 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것배열, 객체 리터럴에서 필요한 값만을 추출하여 변수에 할당할 때 유용하다. 1. 배열 디스트럭처링 할당123456789101112131415161718192021222324252627282930313233// ES5var arr = [1, 2, 3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three); // 1 2 3//// ES6const arr = [1, 2, 3];const [one, two, three] = arr;// 배열 arr을 디스트럭처링하여 할당// 할당 기준은 배열의 indexconsole.log(one, two, three); 1 2 3////// 할당을 위해서는 할당 연산자 왼쪽에 값을 할당 받을 변수를 선언(배열 리터럴)let x, y;[x, y] = [1, 2];// const [x, y] = [1, 2]; 위 아래문은 동치//// 여러 개의 변수를 배열 형태로 선언하면 반드시 우변에 배열을 할당해야한다const [x, y];// SyntaxError: Missing initializer in destructuring declaration//// 변수에 기본값을 설정할 수 있다.let x, y , z;[x, y, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3[x, y = 10, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3 할당 연산자 왼쪽에 값을 할당 받을 변수를 선언해야 한다. (배열리터럴) 할당의 기준은 배열의 인덱스이다. 변수와 배열 요소의 개수가 반드시 일치할 필요는 없다. 변수에 기본값을 설정할 수 있다. Rest 파라미터와 유사하게 Rest 요소를 사용할 수 있다. 12const [x, ...y] = [1, 2, 3];console.log(x, y); // 1 [2, 3] 2. 객체 디스트럭처링 할당ES5, 프로퍼티 키를 이용해서 프로퍼티를 디스트럭처링하여 변수에 할당 1234567891011121314151617181920212223242526272829// ES5var user = { firstName: 'hoyoung'. lastName: 'jung' };var firstName = user.firstName;var lastName = user.lastName;console.log(firstName, lastName); // hoyoung jung//// ES6const user = { firstName: 'hoyoung'. lastName: 'jung' };// 변수를 선언하고 객체 user를 디스트럭처링하여 할당// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어지고, 순서는 의미가 없다.const { firstName, lastName } = user;console.log(firstName, lastName); // hoyoung jung//// 다른 변수 이름으로 프로퍼티 값을 할당받기const user = { firstName: 'hoyoung'. lastName: 'jung' };const { lastName: lN, firstName: fN } = user;console.log(fN, iN); // hoyoung jung// 변수에 기본값 설정const { firstName = 'hoyoung'. lastName } = { lastName: 'jung' };console.log(firName, lastName); // hoyoung jungconst { firstName: fN = 'hoyoung', lastName: lN} = { lastName: 'jung'};console.log(fN, lN); // hoyoung jung 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어지고, 순서는 의미없다. 다른 변수 이름으로 프로퍼티 값을 할당받을 수 있다. 변수에 기본값을 설정할 수 있다. 프로퍼티 키로 객체에서 필요한 프로퍼티 값만을 추출할 수 있다. 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다. 12345678910111213141516171819202122232425262728293031const todo = { id: 1, content: 'HTML', completed: true };const { id } = todo;console.log(id); // 1function printTodo(todo) { console.log(`할일 ${todo.content}은 ${todo.completed} ? '완료' : '바완료') 상태입니다.`);}printTodo({ id: 1, content: 'HTML', completed: true });// 할일 HTML은 완료 상태입니다.////// 배열의 요소가 객체인 경우, 배열 디스트럭처링 할당과, 객체 디스트럭처링 할당 혼용 가능const todos = [ { id: 1, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: false }, { id: 3, content: 'javaScript', completed: true }];const [, { id }] = todos;console.log; // 2//// 중첩 객체의 경우const user = { name: { lastName: 'jung', firstName: 'hoyoung' }};const { name: { lastName }} = user;console.log(lastName); // jung Rest 파라미터와 유사하게 Rest 프로퍼티를 사용할 수 있다. 12const { x, ...rest } = { x: 1, y: 2, z: 3 };console.log(x, rest); // 1 { y: 2, z: 3 }","link":"/2020/03/javaScript/js.Destructuring/"},{"title":"javaScript/js.DOM","text":"Id로 요소 노드 취득 Document.prototype.getElementById 메소드는 인수로 전달한 id어트리뷰트 값을 갖는 하나의 요소 노드를 탐색하여 반환한다. getElementByid 메소드는 Document.prototype의 프로퍼티이다. 반드시 문서 노드 document를 통해 호출해야 한다. 문서 내에 중복된 id 값이 있을 경우, 첫번째 하나의 요소 노드만을 반환한다. 인수로 전달된 id 값을 갖는 요소가 존재하지 않으면, null을 반환한다. id 값과 동일한 이름의 전역 변수가 선언되어 있으면 노드 객체가 재할당되지 않는다. 태그 이름으로 요소 노트 취득Document.prototype/Element.prototype.getElementsByTagName 메소드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환한다. getElementsByTagName 메소드는 여러개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다. 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우, getElementsByTagName 메소드는 빈 HTMLCollection 객체를 반환한다. class로 요소 노드 취득 Document.prototype/Element.prototype.getElementsByClassName 메소드는 인수로 전달한 class 어트리뷰트 값을 갖는 모든 요소 노드들을 탐색하여 반환한다. 인수로 전달할 class 값은 공백으로 구분하여 여러 개의 class를 지정할 수 있다. 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다. 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우, getElementsByClassName 메소드는 빈 HTMLCollection 객체를 반환한다. CSS 선택자로 요소 노드 취득스타일을 적용하고자 하는 HTML 요소를 특정할 때 사용하는 문법이다. 1234567891011121314151617* { ... } /* 전체 선택자: 모든 요소를 선택 */p { ... } /* 태그 선택자: 모든 p 태그 요소를 모두 선택 */#foo { ... } /* id 선택자: id 값이 foo인 요소 모두*/ .foo { ... } /* class선택자: class값이 foo인 요소 모두*/input[type=text] { ... } /* 어트리뷰트 선택자: input 요소중에 type 어트리뷰트 값이 text 요소 모두 */div p { ... }/* 후손 선택자: div 요소의 후손 요소 중 p 요소 모두*/div &gt; p { ... }/* 자식 선택자: div 요소의 자식 요소 중 p 요소 모두*/p + ul { ... }/* 인접 형제 선택자: p 요소의 형제 요소중에 p 요소 바로 뒤에 위치하는 ul 요소*/p ~ ul { ... }/* 일반 형제 선택자: p 요소의 형제 요소중에 p 요소 뒤에 위치하는 ul 요소 모두*/a: hover { ... }/* 가상 클래스 선택자: hover 상태인 a 요소 모두*/ Document.prototype/Element.prototype.querySelector 메소드는 인수로 전달한 CSS 선택자를 만족시키는 하나의 요소 노드를 탐색하여 반환한다. 인수로 전달한 CSS선택자를 만족시키는 요소 노드가 여러개인 경우, 첫번째 요소 노드만 반환 존재하지 않으면 null 반환 Document.prototype/Element.prototype.querySelectorAll 메소드는 인수로 전달한 CSS 선택자를 만족시키는 모든 요소 노드를 탐색하여 반환한다. querySelectorAll 메소드는 여러 개의 요소 노드 객체를 갖는 DOM컬렉션 객체인 NodeList 객체를 반환한다. 요소가 존재하지 않는 경우, 빈 NodeList 객체를 반환한다. CSS 선택자가 문법에 맞지 않은 경우, DOMException 에러가 발생한다. 탐색 가능 여부 확인 Element.prototype.matches 메소드는 인수로 전달된 선택자에 의해 특정 노드를 탐색 가능한지 확인한다. 이벤트 위임을 사용할 경우 유용하다. HTMLCollection 과 NodeList HTMLCollection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체이다. (유사배열 객체이자 이터러블이다)for… of 문으로 순회가능하고, 스프레드 문법을 사용하여 간단한 배열로 변환할 수 있다. 노드 객체의 상태변화를 실시간으로 반영하는 살아있는 객체. HTMLCollection 언제나 live 객체로 동작한다. NodeList 과거의 정적 상태를 유지하는 non-live객체로 동작하지만 경우에 따라 live 객체로 동작하기도 한다. 노드 객체의 상태 변경과 상관없이 안전하게 DOM컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용해야한다. HTMLCollection - forEach, map, filter, reduce NodeList - forEach, item, entries, keys, values 노드 탐색 DOM트리 상의 노드를 탐색할 수 있도록 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공한다. 노드 탐색 프로퍼티는 모두 접근자 프로퍼티이다. 자식 노드 존재 확인 Node.prototype.hasChildNodes 불리언값 반환","link":"/2020/03/javaScript/js.DOM/"},{"title":"javaScript/js.Module","text":"모듈모듈? 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드조각 세부사항을 캡슐화하고 공개가 필요한 API만을 외부에 노출한다. 모듀른 파일 단위로 분리되어 있으며, 애플리케이션은 필요에 따라 명시적으로 모듈을 로드하여 재사용한다.(애플리케이션과 분리되어 개별적으로 존재하다가, 애플리케이션의 로드에 의해 일원이 된다.) 기능별로 분리되어 작성되므로 코드 단위르 명확히 분리한다. 재사용성이 좋아서 효율성, 유지보수성을 높인다. script 태그에 type= “module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. ES6 모듈의 파일 확장자는 모듈임을 명확히 하기위해 mjs를 사용하도록 권장한다. 1&lt;script type=\"module\" src=\"app.mjs\"&gt;&lt;/script&gt; ES6 모듈의 단점 구형 브라우저는 ES6 모듈을 지원하지 않는다. 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하다. 지원하지 않는 기능이 있다. (Bare import 등) 따라서 ES6 모듈기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. 1. 모듈 스코프ES6 모듈 기능을 사용하지 않으면 분리된 자바스크립트 파일에 독자적인 스코프를 갖지 않고, 하나의 전역을 공유한다. 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script src= \"foo.js\"&gt;&lt;/script&gt; &lt;script src= \"bar.js\"&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; foo.js에서 선언한 변수 x와 bar.js에서 선언한 변수 x는 중복 선언되며 의도치않게 변수 x의 값이 덮어 써진다.(하나의 전역 스코프를 갖기 때문이다.) ES6 모듈은 파일 자체의 스코프를 제공. 독자적인 모듈 스코프를 갖는다. 따라서 모듈 내에서 var 키워드로 선언한 변수는 더이상 전역변수가 아니며, window 객체의 프로퍼티도 아니다. 다른 모듈에서 선언한 변수는 모듈 외부에서 참조할 수 없다. (ReferenceError) 12345// foo.mjsvar x = 'foo';console.log(x); //foocnosole.log(window.x); // undifined 2. export 키워드 모듈 안에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할 수 있게 하고싶을 때 export 키워드 사용 선언된 변수, 함수, 클래스 모두 export 가능하다. 선언문 앞에 export 키워드를 사용한다. export는 이름으로 구별할 수 있다. 12345678910111213141516171819// lib.mjs// 변수 공개export const pi = Math.PI;// 함수 공개export function add(x, y) { return x + y;}// 클래스 공개export class Person { constructor(name) { this.name = name; }}// export 대상을 모아 하나의 객체로 구성하여 export 할 수 있다.// 위에 export 키워드가 없을 시export { Pi, add, Person } 3. import 키워드모듈에서 공개(export)한 대상을 로드하려면 import 키워드를 사용한다. 1234567891011121314151617// app.mjs// 같은 폴더 내의 lib.mjs (위 code) 모듈로드// lib.mjs 모듈이 export한 식별자로 import// ES6 모듈의 파일 확장자를 생략할 수 없다.import { Pi, add, Person} from './libmjs';console.log(lib.pi);console.log(lib.add(1, 2));console.log(new lib.Person('jung')); // 이름을 변경하여 importimport { pi as A, add as Plus, Person as name } from './lib.mjs';console.log(A);console.log(Plus(1, 2));console.log(new name('jung')); 모듈에서 하나만을 export할 때는 default 키워드를 사용할 수 있다. default 사용하는 경우, var, let, const 사용불가 default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.12345678910// 모듈에서 하나만 export 할 때는 default 키워드를 사용할 수 있다.// default를 사용하는 경우 var, let, const는 사용할 수 없다.export dafalut function (x, y) { return x + y;}export default () =&gt; {};export default const foo = () =&gt; {}; // SyntaxError : Unexpected token 'const'","link":"/2020/04/javaScript/js.Module/"},{"title":"javaScript/js.ProtoType2","text":"프로토타입(2)10. 프로토타입의 교체프로토타입은 다른 임의의 객체로 변경할 수 있다. (부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미)이러한 특징을 기반으로 객체 간의 상속 관계를 동적으로 변경할 수 있다.프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다. 10.1 생성자 함수에 의한 프로토타입의 교체123456789101112131415const Person = (function () { function Person(name) { this.name = name; } //@생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 //Person 생성자 함수가 생성할 객체의 프로토타입을 객체리터럴로 교체 Person.prototype = { sayHello() { console.log(`Hi! My name is ${this.name}`); } }; return Person;}());const me = new Person('jung'); @에서 Person.prototype에 객체 리터럴을 할당.교체 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. me 객체의 생성자함수를 검색하면 Person이 아닌 Object가 나온다.1234//프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다. console.log(me.constructor === Person); //false//프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다. console.log(me.constructor === Object); //true 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하면 프로토타입의 constructor 프로퍼티를 되살릴 수 있다. 10.2 인스턴스에 의한 프로토타입의 교체인스턴스의 proto 접근자 프로퍼티 (or Object.setPrototypeOf메소드)를통해 타입을 교체할 수 있다. 1234567891011121314151617function Person(name) { tihs.name = name;}const me = new Person('jung');//프로토타입으로 교체할 객체const parent = { sayHello() { console.log(`Hi! My name is ${this.name}`); }}; //@ me 객체의 프로토타입을 parent 객체로 교체Object.setPrototypeof(me, parent);// me.__proto__ = parent; 위 코드와 동일하게 동작me.sayHello(); // Hi! My name is jung 생성자 함수로 프로토타입 교체한 것처럼 프로토타입으로 교체한 객체는 constructor가 없다 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. 11. instanceof 연산자 instanceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 우변의 피연산자가 함수가 아닌 경우 TypeError 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우 false로 평가된다. instanceof 연산자는 상속관계를 고려한다 123456789function Person(name) { this.name = name;}const me = new Person('jung');console.log(me instanceof Person); // trueconsole.log(me instanceof Object); // true// me 객체는 Object.prototype을 상속받기 때문에 아래의 코드 true instanceof 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라 프로토타입 체인 상에 존재하는 프로토타입에 영향을 받는다. ….. 12. 직접 상속12.1 Object.create에 의한 직접 상속Object.create 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.Object.create 메소드도 다른 객체생성방식과 마찬가지로 추상연산 ObjectCreate를 호출한다. Object.create 첫번째 매개변수에 생성할 객체의 프로토타입으로 지정할 객체를 전달,두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다. 이 객체 형식은 Object.definePropeties 메소드의 두번째 인수와 동일하다. Object.create 메소드는 첫번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 객체를 생성하면서 직접적으로 상속을 구현. new 연산자 없이도 객체를 생성할 수 있다. 프로토타입을 지정하면서 객체를 생성할 수 있다. 이때 생성자 함수와 프로토타입 간의 링크가 파괴되지 않는다. 객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다. Object.prototype의 빌트인 메소드는 모든 객체의 프로토타입 체인의 종점인 Object.prototype의 메소드이므로 모든 객체가 상속받아 호출할 수 있다. 1234567const obj = { a: 1 };const child = Object.create(obj);console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.isPrototypeOf(child)); // trueconsole.log(obj.proertyIsEnumerable('a')); //true 12.2 객체 리터럴 내부에서 proto에 의한 직접 상속ES6에서는 객체 리터럴 내부에서 proto 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다. 123456789101112const myProto = { x: 10 };//객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.const obj = { y: 20, __proto__: myProto // obj -&gt; myProto -&gt; Object.prototype -&gt; null};// const obj = Object.create(myProto, { y: { value: 20} }); 위와 동일console.log(obj.x obj.y); // 10 20console.log(Object.getPrototypeOf(obj) === myProto); //true 13. 정적 프로퍼티/메소드정적(static) 프로퍼티, 메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조, 호출할 수 있는 프로퍼티, 메소드를 말한다. 14. 프로퍼티 존재 확인in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다.key : 프로퍼티 키를 나타내는 문자열object: 객체로 평가되는 표현식key in object 1234567891011const person = { name: 'jung' address: 'gimpo'};//person 객체에 name 프로퍼티가 존재한다.console.log('name' in person); // true//person 객체에 address 프로퍼티가 존재한다.console.log('adress' in person); //true//person 객체에 age 프로퍼티가 존재하지 않는다.console.log('age' in person); //false in 연산자는 확인 대상 객체(person객체)의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의. 12console.log('toString' in person); //true//person 객체에는 toString이라는 프로퍼티가 없지만 true in 연산자가 person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문이다. toString은 Object.prototype의 메소드 Object.prototype.hasOwnProperty메소드는 객체 고유의 프로퍼티인 경우에만 true상속받은 프로토타입의 프로퍼티인 경우 false를 반환 15. 프로퍼티 열거15.1 for…in 문객체의 모든 프로퍼티를 순회하며 열거하려면 for…in문을 사용한다. for (변수선언문 in 객체) {…} 1234567891011121314const person = { name: 'jung' address: 'gimpo'};//for ...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다.//순서는 보장되지 않는다.for (const key in person) { console.log(key + ': ' + person[key]);}// name: jung// address: gimpo//2개의 프로퍼티가 있으므로 객체를 2번 순회하면서 프로퍼티 키를 key 변수에 할당한 후 코드블록을 실행한다. for…in 문은 객체의 프로퍼티 개수만큼 반복 in 연산자처럼 순회 대상 객체의 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거 배열에는 for…in문을 사용하지 말고 일반적인 for문이나 for…of문 또는Array.prototype.forEach메소드를 사용하기를 권장 12345678910111213141516171819const arr [1, 2, 3];arr.x = 10; // 배열도 객체이므로 프로퍼티를 가질 수 있다.for (const i in arr) { console.log(arr[i]); //프로퍼티 x도 출력. 1 2 3 10};//arr.length는 3for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); //1 2 3}//forEach 메소드는 요소가 아닌 프로퍼티는 제외한다.arr.forEach( v =&gt; console.log(v)); //1 2 3//for...of는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다.for (const value of arr) { console.log(value); //1 2 3}; 15.2 Object.keys/values/entries 메소드 객체 자신의 프로퍼티만을 열거하기 위해서는 for…in문을 사용하는 것보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다. Object.keys 메소드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다. 1234567const person = { name: 'jung' address: 'gimpo' __proto__: { age: 20 }};console.log(Object.keys(person)); // ['name', 'address'] ES8에서 도입된 Object.values 메소드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다. 1console.log(Object.values(person)); //['jung', 'gimpo'] ES8에서 도입된 Object.entries 메소드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다. 12console.log(Object.entries(person)); //[['name', 'jung'], ['address', 'gimpo']]","link":"/2020/03/javaScript/js.ProtoType2/"},{"title":"javaScript/js.Execution Context","text":"실행 컨텍스트식별자, 호이스팅, 클로저 등의 동작 원리를 담고 있는 자바스크립트 핵심 개념 1. 소스코드의 타입전역코드 전역에 존재하는 소스코드. 전역에 정의된 함수 클래스등의 내부 코드는 포함되지 않는다. 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다. 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다 함수코드 함수 내부에 존재하는 소스코드. 함수 내부에 중첩된 함수, 클래스 등의 내부코드는 포함되지 않는다. 지역 스코프를 생성하고 지역 변수와 매개 변수를 관리해야 한다. 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다. 함수 코드가 실행되면 함수 실행 컨텍스트가 생성된다. eval코드 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. 엄격모드(strict mode)에서 자신만의 독자적인 스코프를 생성한다. eval 코드가 평가되면 eval 실행 컨텍스트가 생성된다. 모듈코드 모듈 내부에 존재하는 소스코드. 모듈 내부의 함수 클래스 등의 내부코드는 포함되지 않는다. 모듈 별로 독립적인 스코프를 생성한다. 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다. 4가지 타입으로 구분하는 이유는 소스코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다. 2. 소스코드의 평가와 실행 모든 소스코드는 실행에 앞서 평가과정을 거치며 코드실행을 위한 준비를 한다. 소스코드 평가과정에서는 실행 컨텍스트를 생성하고, 변수나 함수 등의 선언문 만을 먼저 실행하여 생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록한다. 소스코드의 평가과정이 끝나면 소스코드가 순차적으로 실행되기 시작한다 (선언문 제외) 소스코드 실행에 필요한 정보(변수나 함수)를 실행 컨텍스트가 관리하는 스코프에서 취득한다. 소스코드의 실행결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다. 3. 실행 컨텍스트의 역할12345678910111213const x = 1;const y = 1;function foo(a) { const x = 10; const y = 20;}console.log(a + x + y); //130foo(100);console.log(x + y); //3 1. 전역 코드 평가 전역코드를 실행하기 앞서, 전역코드 평가 과정을 거치며 전역코드 실행을 위한 준비를 한다. 전역코드의 변수 선언문과 함수 선언문이 먼저 실행, 그 결과 생성된 전역변수와 전역함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록 var 키워드로 선언된 전역변수와 함수 선언문으로 정의된 전역함수는 전역 객체의 전역 객체 프로퍼티와 메소드가 된다. 2. 전역 코드 실행 전역코드 평가가 끝나면 전역 코드가 순차적으로 실행 전역변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역코드의 실행을 일시 중단하고 코드 실행 순서를 함수 내부로 진입 3. 함수 코드 평가 함수 내부의 문들을 실행하기 앞서 함수코드 평가 과정을 거치며 함수코드 실행을 위한 준비를 한다. 매개 변수와 지역변수 선언문이 먼저 실행되고 그 겨롹 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. arguments 객체도 생성되어 지역 스코프에 등록된다 (함수내부에서 지역변수) 4. 함수 코드 실행 함수코드가 순차적으로 실행, 매개변수와 지역변수에 값이 할당되고 console.log 메소드가 호출된다. console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색식별자 console은 스코프체인에 등록 되어있지않고, 전역 객체에 프로퍼티로 존재이것은 전역객체의 프로퍼티가 마치 전역변수처럼 전역 스코프에서 검색 가능해야 한다는 것을 의미 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색 그 후 console.log 메소드의 인수로 전달된 표현식 a + x + y 가 평가된다. console.og 메소드의 실행이 종료되면 함수코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역코드 실행을 계속한다. 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다. 전역객체의 프로퍼티도 전역변수처럼 검색할 수 있어야 한다. 스코프, 식별자, 코드실행순서 등의 관리가 필요하다. 실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 식별자와 스코프는 실행 컨텍스트의 렉시컬환경으로 관리 코드실행 순서는 실행 컨텍스트 스택으로 관리 4. 실행 컨텍스트 스택 ( 콜스택 Call stack)자바스크립트 엔진은 먼저 전역코드를 평가하여 전역 실행 컨텍스트를 생성한다.그리고 함수가 호출되면 함수코드를 평가하여 함수 실행 컨텍스트를 생성한다.이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 이를 실행 컨텍스트 스택이라고 한다. 코드의 실행 순서를 관리한다. 소스코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다. 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트이다. (running execution context) 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 5. 동기식 처리 모델과 비동기식 처리 모델동기식 처리모델 (Syncharonous processing model) 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것 직렬적으로 태스크를 수행한다. 순차적으로 실행되며 어떤 작업이 수행중이면 다음 작업은 대기한다. 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹된다.블로킹(blocking , 작업중단) 비동기식 처리모델 (Asynchronous processing model , Non- Blocking) 병렬적으로 태스크를 수행 태스크가 종료되지 않은 상태라도 대기하지 않고 다음 태스크를 실행한다. Timer 함수 (setTimeout, setInterval), Ajax 요청 자바스크립트에 동시성을 부여하여 싱글 스레드의 약점을 보완해준다. 하지만 코드가 순차적으로 실행되지 않아 가독성이 안좋고 콜백 헬?을 유발하여 에러 처리가 어렵다는 약점을 가지고 있다. 6. 렉시컬 환경 (Lexical Environment)식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 환경으로 실행 컨텍스트를 구성하는 컴포넌트이다.실행 컨텍스트 스택 - 코드의 실행순서 관리렉시컬 환경 - 스코프와 식별자 관리 렉시컬 환경은 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다. 렉시컬 환경의 구성 컴포넌트 환경 레코드 - 스코프에 포함된 식별자를 등록된 식별자에 바인딩된 값을 관리하는 저장소이다. 소스코드 타입에 따라 내용에 차이가 있다. 외부 렉시컬 환경에 대한 참조 - 상위 스코프를 가리킨다. 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 단뱡향 링크드 리스트인 스코프 체인을 구현한다. 7. 실행 컨텍스트의 생성과 식별자 검색 과정7.1 전역 객체 생성 전역 객체는 전역 코드가 평가되기 이전엔 생성된다. 전역 객체는 전역 프로퍼티와 전역함수, 표준 빌트인 객체가 추가되며 동작 환경에 따라 클라이언트 사이트 Web API 또는 특정 환경을 위한 호스트 객체를 포함한다. Object.prototype을 상속받는다. -&gt; 전역 객체도 프로토타입 체인의 일원이다. 7.2 전역 코드 평가소스코드가 로드되면 자바스크립트 엔진은 전역코드를 평가한다.세부적 생성과정 1. 전역 실행 컨텍스트 생성 전역 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다. 이때 전역 실행컨텍스트는 실행 컨텍스트의 스택의 최상위인 실행 중인 실행 컨텍스트가 된다. 2. 전역 렉시컬 환경 생성 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. 2.1 전역 환경 레코드 생성 객체 환경 레코드, 선언적 환경 레코드로 구성 되어있다. 서로 협력하여 전역 스코프 전역 객체를 관리한다. 객체 환경 레코드 var키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수, 그리고 표준 빌트인 객체, 전역 빌트인 프로퍼티 및 메소드 관리 BindingObject라고 부르는 객체와 연결된다. 선언적 환경 레코드 - let, const키워드로 선언한 전역 변수를 관리 ㅣet, const키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재하게 되는데, 여기서 말하는 개념적인 블록이 바로 선언적 환경 레코드이다. 2.2 외부 렉시컬 환경에 대한 참조 할당 외부 렉시컬 환경에 대한 참조는 현재 평가 중인 코드를 포함하는 외부 코드의 렉시컬 환경, 즉 상위 스코프를 가리킨다. 전역 코드를 포함하는 코드가 없다면 null이 할당된다. 이는 전역 렉시컬 환경이 스코프 체인의 최상위에 존재함을 의미한다. 2.3 this 바인딩 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.(전역 코드에서 this는 전역 객체를 가리키므로) 전역코드에서 this를 참조하면 전역 환경 레코드의 [[GlobalThisValue]]내부 슬롯에 바인딩 되어있는 객체가 반환된다. 전역 환경 레코드를 구성하는 객체환경 레코드, 선언적환경 레코드에는 this 바인딩 X this 바인딩은 전역환경 레코드와 함수환경 레코드에만 존재한다. 7.3 전역 코드 실행 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수, 함수 이름이 선언된 식별자인지 확인해야 한다. 선언된 식별자인지, 어느 스코프의 식별자를 참조하면 되는지를 결정하는게 식별자 결정(identifier resolution)이라 한다. 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경레코드에 등록되어 있다. 전역 렉시컬 환경은 스코프 체인의 종점이므로 전역 렉시컬 환경에서 검색할 수 없는 식별자는 참조 에러를 발생시킨다. 7.4 함수 코드 평가 함수가 호출되면 전역 코드의 실행을 일시 중단하고 함수 내부로 코드의 제어권이 이동한다.그리고 코드를 평가하기 시작한다. 세부적인 생성 과정 함수 실행 컨텍스트 생성 (실행 컨텍스트 스택의 최상위) 함수 렉시컬 환경 생성 (함수 실행 컨텍스트에 바인딩한다.) 함수 환경 레코드 생성 (매개변수, arguments객체, 함수내에서 선언한 지역 변수와 함수 정의를 등록하고 관리) 외부 렉시컬 환경에 대한 참조 할당 (함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.) this 바인딩 (함수 환경 레코드의 [[ThisValue]]내부 슬롯에 this가 바인딩된다.) 7.5 함수 코드 실행 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다. 식별자 console 식별자를 스코프 체인에서 검색한다. 식별자를 검색할 때는 언제나 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색하기 시작한다. console 식별자는 객체 환경 레코드의 BinginObject (전역객체)에서 찾을 수 있다. console 객체의 프로토타입을 통해 log 메소드를 검색한다 (console 식별자에 바인딩된 객체) log 메소드는 상속된 프로퍼티가 아니라 console이 직접 소유하는 프로퍼티 console.log 메소드 호출 7.6 함수 코드 실행 종료함수가 종료하면 더이상 실행할 코드가 없으므로 함수 코드의 실행이 종료된다.실행 컨텍스트 스택에서 함수 실행 컨텍스트가 팝되어 제거되고 전역 컨텍스트가 실행 중인 실행 컨텍스트가 된다. 7.7 전역 코드 실행 종료전역 코드의 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다. 8. 실행 컨텍스트와 블록 레벨 스코프12345678let x = 1;if (true) { let x = 10; console.log(x) //10}console.log(x) //1 if문의 코드 블록 내에서 let 키워드로 변수 선언 if문이 실행되면 if문의 블록 레벨 스코프를 생성해야한다. if문을 위한 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. 새롭게 생성된 if문을 위한 렉시컬 환경의 외부 렉시컬에 대한 참조는 교체된 이전의 전역 렉시컬 환경을 가리킨다. if문이 종료되면 if문이 실행되기 이전의 렉시컬 환경으로 되돌린다. if문 뿐만 아니라 모든 블록문에 적용된다.","link":"/2020/03/javaScript/js.Execution%20Context/"},{"title":"javaScript/js.Operator","text":"연산자 (Operator) 연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수햏애 하나의 값을 만든다. 연산의 대상을 피연산자(Operand)라 한다. 피연산자는 값을 평가 될 수 있는 표현식이여야 한다. 피연산자와 연산자의 조합으로 이루어진 연산자 표현식도 값으로 평가될 수 있는 표현식이다. 피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다. 1. 산술연산자 산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다. 이항 산술 연산자 이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자타입의 값을 만든다. 모든 이항 산술 연산자는 피연산자의 값을 변경하는 side effect가 없다. (어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없다.) 단항 산술 연산자 1개의 피연산자를 산술하여 숫자 타입의 값을 만든다. 증가/감소 (++/–) 연산자는 피연산자의 값을 변경하는 부수효과가 있다. (암묵적 할당이 이루어진다.) 증가/감소 (++/–) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다. 123456var number = 10;alert(number++); //10alert(++number); //12alert(number--); //12alert(--number); //10 +, - 단항 연산자는 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변한화여 반환한다. 문자열 연결 연산자 +연산자는 피연산자 중 하나 이상의 문자열인 경우 문자열 연결 연산자로 동작한다. 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다 123451 + true; //21 + false; //1undefined는 숫자로 타입 변환되지 않는다.1 + undefined; NaN 이를 암묵적 타입변환(Implicit coercion) or 타입 강제 변환(Type coercion)라한다. 2. 할당 연산자 할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수효과가 있다. 12345문자열 연결 연산자var str = 'My name is';str += 'Jung';console.log(str); //'My name is Jung' 할당 연산은 값으로 평가되는 표현식인 문이다.3. 비교 연산자 비교연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다. 제어문(if문, for문)의 조건식에서 주로 사용 일치 비교 연산자 동등 비교 (==)연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후, 같은 값인지 비교 타입 고려 X 값만 따진다. 따라서, 정확한 비교를 위해서는 일치 비교 연산자(===)로 비교해야한다. 암묵적 타입변환을 하지않고, 값과 타입을 고려해 비교하기때문이다. NaN은 제외 (자신과 일치하지 않는 유일한 값) 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다. 대소 관계 비교 연산자 피연산자의 크기를 비교하여 불리언 값을 반환한다. 4. 삼항 조건 연산자 삼항 조건 연산자(ternary oprator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 값으로 평가할 수 있는 표현식인 문이다. 어떤 값을 결정해야 한다면 if..else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. (수행해야할 문이 여러개라면 if..else문이 가독성이 좋음) 조건식? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 123456var x = 2;//2 % 2는 0, 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수' ;console.log(result); //짝수 5. 논리 연산자 논리 연산자(Logical Operator)는 우항과 좌항의 피연산자를 논리 연산한다. 논리 연산자 의미 부수 효과 &amp;&amp; 논리곱(AND) X ! 부정(NOT) X ` ` 123456789101112131415//논리합(||) 연산자true || true; //truetrue || false; //true 좌항이 true인 경우, 연산종료?false || true; //truefalse || false; //false//논리곱(&amp;&amp;) 연산자true &amp;&amp; true; //truetrue &amp;&amp; false; //falsefalse &amp;&amp; true; //false false &amp;&amp; false; //false//논리 부정(!) 연산자!true; //false!false; //true 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 피연산자가 반드시 불리언 값일 필요는 없다. 불리언 값이 아니라면, 불리언 타입으로 암묵적 타입 변환된다. 논리합(||), 논리곱(&amp;&amp;) 연산자의 평가 결과는 불리언이 아닐 수도 있다. 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다. 6. 쉼표 연산자 쉼표 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 7. 그룹 연산자 그룹 연산자는 피연산자의 표현식을 가장 먼저 평가한다. 연산자 우선순위를 조절할 수 있다. 8. typeof 연산자 typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. null 값은 ‘null’ 이 아닌 ‘object’를 반환 -&gt; 버그 9. 지수 연산자 ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 지수 연산자는 모든 이항 연한자보다 우선순위가 높다.122 ** 2; // 42 ** 1; // 2 10. 연산자의 부수 효과 부수 효과가 있는 연산자 할당 연산자(=), 증가/감소연산자(++/–), delete 연산자 할당 연산자는 변수를 사용하여 다른 코드에 영향을 준다. delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.","link":"/2020/02/javaScript/js.Operator/"},{"title":"javaScript/js.Timer","text":"타이머 함수들은 모두 window의 메소드 모두 일정 시간이 경과된 이후 콜백 함수를 호출하는 타이머를 설정 비동기적 (asynchronous)으로 동작한다. ( 싱글 스레드로 동작하기 때문) ECMAScript 표준사양은 아니나 브라우저, Node,js환경에서 모두 제공한다. setTimeout / clearTimeoutsetTimeout 함수는 두번째 인수로 전달한 시간이 경과한 이후에 첫번째 인수로 전달한 콜백 함수를 단 한번 호출한다. 1234567891011// 1초 후에 첫번째 인수로 전달한 함수 호출setTImeout(() =&gt; console.log('Hi'), 1000);// 1초 후에 첫번째 인수로 전달한 함수에 인수를 전달하면서 호출setTImeout(name =&gt; console.log(`Hi ${name}.`) 1000, 'jung');// 지연 시간을 생략하면 기본값이 0 지정setTImeout(() =&gt; console.log('Hi'));const Timeout = setTimeout(() =&gt; console.log('Hi'), 1000);clearTimeout(Timeout);// 타이머 취소 setInterval / clearIntervalsetInterval 함수는 두번째 인수로 전달한 시간이 경과할 때 마다 첫번째 인수로 전달한 콜백 함수를 타이머가 취소될 때까지 호출한다. 123456let count = 1;const timeOutId = setInterval(() =&gt; { console.log(count); if (count++ === 5) clerarInterval(timeOutId);}, 1000);","link":"/2020/04/javaScript/js.Timer/"},{"title":"javaScript/js.ProtoType1","text":"프로토타입(1)1. 객체지향 프로그래밍 (OPP, Object Oriented Programming) 객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임 상태 데이터와 동작을 하나의 논리적 단위로 묶음 복합적인 자료구조 객체의 상태 데이터 - 프로퍼티(property), 동작 - 메소드(method) 각각의 객체는 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 갖을 수 있다. 2. 상속과 프로토타입 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있다. 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. -&gt; 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다. 1234567891011121314151617181920//생성자 함수function Circle(radius) { this.radius = radius;}//Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토 타입에 추가한다.// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어있다.Circle.prototype.getArea = funciton = () { return Math.PI * MAth.pow(this.radius, 2);};//인스턴스 생성const circle1 = new Circle(1);const circle2 = new Circle(2);//Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는 프로토타입//Circle.prototype로부터 getArea 메소드를 상속받는다.//즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.console.log(circle1.getArea === circle2.getArea); // trueconsole.log(circle1.getArea()); // 3.14~console.log(circle2.getArea()); // 12.56~ getArea 메소드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메소드로 할당 Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메소드를 상속받아 사용할 수 있다. 자신의 상태를 나타내는 radius 프로퍼티만을 개별적으로 소유하고 내용이 동일한 메소드는 상속을 통해 공유하여 사용하는 것이다. 3. 프로토타입 객체 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 갖고, 생성될 때 [[Prototype]]내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다. 프로토타입은 객체이거나 null. 모든 프로토타입은 생성자 함수와 연결되어 있다. 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다. 3.1 proto 접근자 프로퍼티 모든 객체는 proto 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다. 모든 객체는 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근하기 위해 proto 접근자 프로퍼티를 사용할 수 있다. 내부 슬롯은 프로퍼티가 아니다. proto 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있다. Object.prototype.proto 는 접근자 프로퍼티이다. 12345678const obj = {};const parent = { x: 1 };// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득obj.__proto__;// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체obj.__proto__ = parent;console.log(obj.x); //1 get proto 는 [[GetPrototypeOf]] 내부 메소드를 호출하여 자신의 프로토타입을 취득 set proto 은 [[SetPrototypeOf]] 내부 메소드를 호출하여 새로운 프로토타입을 할당한다. proto 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.proto 접근자 프로퍼티를 사용할 수 있다. 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참좀에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다. 12345const parent = {};const child = {};child.__proto__ = parent;parent.__proto__ = child; //TypeError: Cyclic __proto__ value 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 순환 참조적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 무한루프에 빠진다. proto 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우는 Object.getPrototypeOf메소드, 프로토타입을 교체하는 경우는 Object.setPrototypeOf 메소드를 사용하는 것을 권장 12345678const obj = {};const parent = { x: 1 };//obj 객체의 포로토타입을 취득Object.getPrototypeOf(obj); //obj.__proto__;//obj 객체의 프로토타입을 교체Object.getPrototypeOf(obj, parent); //obj.__proto__ = parent;console.log(obj.x); //1 3.2 함수 객체의 prototype 프로퍼티 함수 객체는 proto 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 생성자 함수로서 호출할 수 없는 함수, Arrow, Method인 함수 (non-constructor)는 프로토타입이 생성되지 않으며 prototype 프로퍼티도 소유하지 않는다. 모든 객체가 가지고 있는 proto 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 동일한 프로토타입을 가리킨다. (프로퍼티를 사용하는 주체는 다르다) 3.3 프로로타입의 constructor 프로퍼티와 생성자 함수 모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.12345678//생성자 함수function Person(name) { this.name = name;}const me = new Person('Jung');//me 객체의 생성자 함수는 Person이다.console.log(me.constructor === Person); // true me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로포타입인 Person.prototype에 constructor 프로퍼티가 있다. 상속받아서 사용할 수 있다. 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토 타입생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다. 123456789101112//obj 객체를 생성한 생성자 함수는 Object이다.const obj = new Object();//add 함수 객체를 생성한 생성자 함수는 Function이다.const add = new Function('a', 'b', 'return a+b');//생성자 함수 function Person(name) { this.name = name;}//me 객체를 생성한 생성자 함수는 Person이다.const me = new Person('Jung'); 리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재. 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다. 5. 프로토타입의 생성 시점5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 생성된 프로토타입은 생성자 함수의 protytype 프로퍼티에 바인딩된다. 생성된 프로토타입은 constructor 프로퍼티만을 갖는 객체이다. 생성된 프로토타입의 프로토타입은 Object.prototype이다. non-constructor는 프로토타입이 생성되지 않는다. 5.2 빌트인 생성자 함수와 프로토타입 생성 시점 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성됟는 시점에 프로토타입이 생성 모든 빌트인 생성자 함수는 전역객체가 생성되는 시점에 생성된다. 이때, 프로토타입도 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다. 123// 전역객체 window는 브라우저에 종속적이므로 아래 코드는 브라우저 환경에서 실행해야한다.// 빌트인 객체인 Object는 전역 객체 window의 프로퍼티이다.window.Object === Object // true 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되서 존재함 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[prototype]] 내부 슬롯에 할당된다. -&gt; 생성된 객체는 프로토타입을 상속받는다. 6. 객체 생성 방식과 프로토타입의 결정객체 생성방법 5가지 객체 리터럴, Object 생성자함수, 생성자함수, Object.create 메소드, 클래스 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다. 추상연산 ObjectCreate은 런타임에 새로운 객체를 생성하고, 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다. 자신이 생성할 객체에 추가할 프로퍼티 목록은 옵션으로 전달할 수 있다. ObjectCreate 는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티목록(internalSlotList)이 인수로 전달된 경우, 프로퍼티를 객체에 추가한다. 인수로 전달받은 프로토타입을 자신이 생성한 객체의 [[Prototype]] 내부슬롯에 할당한 다음, 생성한 객체를 반환한다. 프로토타입은 추상연산 ObjectCreate에 전달되는 인수(proto)에 의해 결정된다. 6.1 객체 리터럴에 의해 생성된 객체의 프로토타입자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, ObjectCreate를 호출한다.이때 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 1234const obj = { x: 1 };//객체 obj는 Object.prototype을 상속받는다.console.log(obj.constructor === Object); // trueconsole.log(obj.hasOwnProperty('x')); //true 6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입 명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 ObjectCreate를 호출한다. 이때, ObjectCreate에 전달되는 프로토타입은 Object.prototype이다.즉, Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다123456const obj = new Object();obj.x = 1;//객체 obj는 Object.prototype을 상속받는다.console.log(obj.constructor === Object); //trueconsole.log(obj.hasOwnProperty('x')); //true 객체 리터럴과 Object 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있다. 객체 리터럴 방식 - 객체 리터럴 내부에 프로퍼티를 추가 Object 생성자 함수 방식 - 빈 객체 생성 후 프로퍼티를 추가 6.3 생성자 함수에 의해 생성된 객체의 프로토타입 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식처럼 ObjectCreate를 호출한다. ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체이다. 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩 되어있는 객체이다. 1234567891011121314function Person(name) { this.name = name;}//프로토타입 메소드Person.prototype.sayHello = function () { console.log('Hi! My name is ${this.name}');};const me = new Person('Jung');const you = new Person('Lee');me.sayHello(); //Hi! My name is Jungyou.sayHello(); //Hi! My name is Lee 프로토타입 Person.prototype에 프로퍼티를 추가하여 하위 객체가 상속받을 수 있다. 프로토타입은 객체. 일반 객체처럼 프로토타입에 프로퍼티를 추가/삭제할 수 있다. 추가/삭제된 프로퍼티는 프로퍼티 체인에 즉각 반영된다. 7. 프로토타입 체인 자바스크립트는 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 proto 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 프로토타입 체인의 최상위에 위치한 객체는 언제나 Object.prototype이다. Object.prototype의 프로토타입, 즉 [[Prototype]] 내부 슬롯의 값은 null이다. 프로토타입 체인의 종점인 Object.prototype에서도 프로퍼티를 검색할 수 없는 경우, undefined를 반환한다. 스코프체인과 프로토타입체인은 서로 협력하여 식별자와 프로퍼티를 찾아낸다. 8. 캡슐화1234567891011121314const Person = (function () { //생성자 함수 function Person(name) { this.name = name; } //프로토타입 메소드 Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`); }; //생성자 함수 반환 return Person;}());const me = new Person('Jung'); 즉시 실행 함수를 사용하여 생성자 함수와 프로토타입을 확장하는 코드를 하나의 함수 내에 모을 수 있다. 캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉하는 것을 말한다. 외부에 공개할 필요가 없는 일부를 외부에 노출하지 않도록 감추어 정보를 보호, 객체간의 상호 의존성(결합도)를 낮추는 효과 프로퍼티를 캡슐화 예시 1234567891011121314151617181920const Person = (function () { let _name = ''; //자유 변수이며 private함 // 생성자 함수 function Person(name) { _name = name; } // 프로토타입 메소드 Person.prototype.sayHello = function () { console.log(`Hi! My name is ${_name}`); }; //생성자 함수를 반환 return Person;}());const me = new Person('jung');me._name = 'Lee';me.sayHello(); //Hi My name is jung//_name은 지역 변수이므로 외부에서 접근하여 변경 불가 9. 오버라이딩과 프로퍼티 쉐도잉 오버라이딩(Overriding)상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식 오버로딩(Overloading) 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수 있다. 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다.호출했을때, 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다. 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. 프로토타입 프로퍼티를 변경 또는 삭제하려면 프로토타입에 직접 접근해야한다. (하위객체 통하지말고)","link":"/2020/03/javaScript/js.ProtoType1/"},{"title":"javaScript/js.array2","text":"9. 배열 고차 함수고차 함수(Higher-Order-Function, HOF)는 함수를 인자로 전달받거나 함수를 반환하는 함수를 말한다. 9.1 Array.prototype.sort 배열의 요소를 적절하게 정렬한다. 원본 배열을 직접 변경한다. 기본적으로 오름차순(ascending)으로 요소를 정렬한다. 내림차순은 먼저 오름차순으로 정렬 후 순서를 뒤집는다. 12345const fruits = ['바나나', '오렌지', '사과'];fruits.sort();console.log(fruits); //['바나나', '사과', '오렌지']fruits.reverse(); // 내림차순(descending)console.log(fruits); // ['오렌지', '사과', '바나나'] 문자열 정렬은 문제가 없으나 숫자 요소들을 정렬할 떄 문제 발생 배열의 요소를 일시적으로 문자열로 변환한 후 정렬한다. (Unicode 코드 포인트 순서) 정렬 순서를 정의하는 비교 함수를 인수로 전달해야한다. 12345678const points = [40, 100, 5, 1, 3, 28]points.sort(function (a, b) { return a - b; });// points.sort((a, b) =&gt; a - b);console.log(points); // [1 , 3, 5, 28, 40, 100]//// points.sort(function (a, b) { return b - a; }); //내림차순// points.sort((a, b) =&gt; b - a); 9.2 Array.prototype.forEach for문을 대체할수 있는 메소드 배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다. forEach 메소드의 콜백함수는 요소값, 인덱스, forEach 메소드를 호출한 배열,즉 this를 전달 받을 수 있다. 원본 배열을 변경하지 않는다. 하지만 콜백 함수가 원본 배열을 변경할 수 있다. 123456789101112131415161718192021const numbers = [1, 2, 3];let pows =[];// for문for (let i = 0; i &lt; numbers.length i++) { pows.push(numbers[i] ** 2);}console.log(pows); // [1, 4, 9]//// forEach 문numbers.forEach(item =&gt; pows.push(item ** 2));consoel.log(pows); //[1, 4, 9]////// 원본 배열 변경에 대해const numbers = [1, 2, 3];numbers.forEach((item, index, arr) =&gt; arr[index] = Math.pow(item, 2));// 원본 배열을 직접 변경하려면 콜백함수의 3번째 인자를 사용한다.//// forEach 메소드의 반환값은 언제나 undifinedconst result = [1, 2, 3].forEach(console.log);console.log(result); //undifined break, continue 문을 사용할 수 없다. (SyntaxError) 배열의 모든 요소를 모두 순회해야하며, 중간에 순회를 중단할 수 없다. 희소 배열의 존재하지 않는 요소는 순회 대상에서 제외된다.for문에서는 undifined, forEach메소드에서는 무시 9.3 Array.prototype.map 배열을 순회하며 배열의 각 요소에 인수로 전달된 콜백 함수를 실행한다. 콜백 함수의 반환값들이 요소로 추가된 새로운 배열을 반환한다. 원본 배열은 변경되지 않는다. 배열을 순회하며 요소값을 다른값으로 맵핑하기 위한 함수 map 메소드가 생성하여 반환하는 새로운 배열의 length는 map 메소드를 호출한 배열,즉 this의 length와 반드시 일치한다. ( 1:1 mapping)12345const numbers = [1, 4, 9];const roots = numbers.map(item =&gt; Math.sqrt(item));// const roots = numbers.map(Math.sqrt);console.log(roots); // [1, 2, 3]console.log(numbers); // [1, 4, 9] 9.4 Array.prototype.filter 배열을 순회하며 배열의 각 요소에 인수로 전달된 콜백 함수를 실행한다. 콜백 함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열로 반환한다. 반대로 특정요소를 제거하기위해 쓰기도 한다. 원본 배열은 변경되지 않는다.123const numbers = [1, 2, 3, 4, 5];const odds = numbers.filter(item =&gt; item % 2);console.log(odds); // [1, 3, 5] 9.4 Array.prototype.reduce 배열을 순회하며 콜백함수의 이전 반환값과 배열의 각요소에 인수로 전달된 콜백함수를 실행하여 하나의 결과값을 반환한다. 원본 배열은 변경되지 않는다. 첫번째 인수 - 콜백함수 , 두번째 인수 - 초기값을 전달받는다. reduce 메소드의 콜백함수에는 4개의 인수 (초기값or콜백함수의 이전 반환값, 요소값, 인덱스, reduce 메소드를 호출한 배열(this))가 전달된다. 123456789// 1부터 4까지의 누적const sum = [1, 2, 3, 4].reduce((accumulator, currentValue, index, array) =&gt; accumulator + currentValue, 0); //10//// 평균 구하기const values = [1 ,2 ,3, 4, 5];const average = values.reduce((acc, cur, i, { length }) =&gt; { return i === length - 1 ? (acc + cur) / length : acc + cur;}, 0);console.log(average); // 3 map, filter, some, every, find와 같은 모든 배열 고차함수는 reduce로 구현할 수 있다. 두번째 인수로 전달하는 초기값은 옵션이다. (생략가능). 하지만 전달하는 것이 안전하다. 9.6 Array.prototype.some 배열을 순회하며 각 요소에 인수로 전달된 콜백 함수를 실행하여 그 결과가 하나라도 참이라면 true, 모두 거짓이라면 false를 반환한다. 배열 요소 중에 콜백 함수를 통해 정의한 조건을 만족하는 요소가 1개 이상이 존재하는지 확인하여 그 결과를 불리언 타입으로 반환한다.12345let result = [5, 10, 15].some(item =&gt; item &gt; 10);cosnole.log(result); // true//fruits = ['apple', 'banana', 'orange'].some(item =&gt; item === 'apple');console.log(fruits); // true 9.7 Array.prototype.every 배열을 순회하며 각 요소에 인수로 전달된 콜백 함수를 실행하여 그 결과가 모두 참이라면 true, 하나라도 거짓이면 false를 반환한다. 콜백 함수를 통해 정의한 조건을 모두 만족하는지 확인하여 결과를 불리언 타입으로 반환한다.1234let result = [5, 10, 15].every(item =&gt; item &gt; 3);console.log(result); //trueresult = [5, 10, 15 ].every(item =&gt; item &gt; 10);console.log(result); //false 9.8 Array.prototype.find ES6에서 새롭게 도입됌 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다. 실행 결과가 참인 요소가 존재하지 않는다면 undifined를 반환한다.1234567891011const users = { { id: 1, name: 'jung'}, { id: 2, name: 'song'}, { id: 3, name: 'yoo'}, { id: 4, name: 'park'}};const result = users.find(item =&gt; item.id === 2);console.log(result); // {id: 2 name: 'song'}// 요소를 반환한다는 거에 주의하자.// filter는 배열 반환 , find는 요소 반환 9.9 Array.prototype.findIndex ES6에서 새롭게 도입됌 콜백 함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다. 실행 결과가 참인 요소가 존재하지 않는다면 -1를 반환한다.123456789101112131415const users = { { id: 1, name: 'jung'}, { id: 2, name: 'song'}, { id: 3, name: 'yoo'}, { id: 4, name: 'park'}};function predicate(key, value) { //key와 value를 기억하는 클로저를 반환 return item =&gt; item[key] === value;}let index = users.findIndex(predicate('id', 2));console.log(index); //1index = users.findIndex(predicate('name', 'jung'));console.log(index); //0 9.10 Array.prototype.flatMap ES10에서 새롭게 도입됌 map을 통해서 생성된 새로운 배열을 평탄화한다. map 메소드와, flat 메소드를 순차적으로 실행하는 효과가 있다. 1단계만 평탄화 한다. (평탄화 깊이 지정 X)12345let arr = ['hello', 'young'];console.log(arr.map(str =&gt; str.split('')).flat());// ['h', 'e', 'l', 'l', 'o', 'y', 'o', 'u', 'n', 'g']console.log(arr.flatMap(str =&gt; str.split('')));// ['h', 'e', 'l', 'l', 'o', 'y', 'o', 'u', 'n', 'g']","link":"/2020/03/javaScript/js.array2/"},{"title":"javaScript/js.built-in object","text":"빌트인 객체1. 자바스크립트 객체의 분류자바스크립트 객체는 크게 3개의 객체로 분류할 수 있다. 표준 빌트인 객체(standard built-in objects, navtive object, global ojbects) ECMAScript 사양에 정의된 객체, 애플리케이션 전역의 공통 기능을 제공 자바스크립트 실행환경과 관계없이 언제나 사용 가능 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 별도의 선언없이 전역 변수처럼 언제나 참조할 수 있다. 호스트 객체 (host objects) ECMAScript에 정의되어 있지 않음, 자바스크립트 실행환경에서 추가적으로 제공하는 객체 브라우저 환경에서는 클라이언트 사이드 Web API를 호스트 객체로 제공 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공 사용자 정의 객체 (user-defined objects) 기본으로 제공되는 객체가 아닌 사용자가 직접 정의한 객체 2. 표준 빌트인 객체 자바스크립트는 Object, String, Number, Boolean, Symbol, Date, Math, REgExp, Array, FUnction 등.. 40 여개의 표준 빌트인 객체를 제공한다. 표준 빌트인 객체는 인스턴스를 생성할 수 있는 생성자 함수 객체이다. (Math, Reflect, JSON 제외) 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다. 1234567891011121314151617181920212223242526272829const strObj = new String('jung');console.log(typeof strObj); //objectconsole.log(strObj); //String {'jung'}const numObj = new Num(123);console.log(typeof numObj); //objectconsole.log(numObj); // Number {123}const boolObj = new Boolean(true);console.log(typeof boolObj); //objectcosole.log(boolObj); //Boolean{true}const func = new Function('x', 'return x * x');console.log(typeof func); //functionconsole.dir(func); // ƒ anonymous( x )const arr = new Array(1, 2, 3);console.log(typeof arr); //objectconsole.log(arr); // [1, 2, 3]``` - 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은, 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다.- 표준 빌트인 객체인 String을 생성자 함수로서 호출하여 생성한 String 인스턴스의 프로토타입은 String.prototype이다.```javascript//String 생성자 함수에 의한 String 객체 생성const strObj = new String('jung');console.log(typeof strObj); // objectconsole.log(strObj); //String {'jung'}console.log(Object.getPrototypeOf(strObj) === String.prototype); //true 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체(String.prototype)는 다양한 기능의 메소드를 제공. 인스턴스 없이도 호출 가능한 정적 메소드도 제공한다. 3. 원시값과 래퍼 객체 (wrapper object)원시값은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없음에도 불구하고 원시값인 문자열이 마치 객체처럼 동작한다. 1234const str = 'hello';console.log(str.length); //5console.log(str.toUpperCase()); //HELLO 표준 빌트인 객체가 제공하는 프로토타입 메소드를 사용하려면 반드시 인스턴스를 생성하고 인스턴스로 프로토타입 메소드를 호출해야한다. 위 예제는 원시값으로 표준 빌트인 객체의 프로토타입 메소드를 호출하면 정상적으로 동작한다. 이는 원시값인 문자열, 숫자, 불리언 값의 경우 마치 객체처럼 이들 원시값에 대해 마침표 표기법(or 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다. 문자열, 숫자 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라 한다. 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다. (number, boolean, Symbol도)12345678910const str = 'hi';//원시 타입인 문자열이 -&gt; 래퍼 객체인 String 인스턴스로 변환된다.console.log(str.length); //2console.log(str.toUpperCase()); //HI//래퍼 객체로 프로퍼티 접근이나 메소드 호출한 후, -&gt; 다시 원시값으로 되돌린다.console.log(typeof str); //string//이 때 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype의 메소드를 상속받아 사용할 수 있다. 123456const str = 'hello';str.name = 'jung'; //래퍼 객체에 프로퍼티 추가// 위 코드의 래퍼 객체가 아닌 새로운 래퍼 객체를 가리킨다.console.log(str.name); // undefined String, Number, Boolean, Symbol 이외의 원시값은 래퍼 객체를 생성하지 않는다. 원시값 null, undefined 래퍼 객체가 없다. 객체처럼 사용하면 에러발생 4. 전역 객체전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않는 최상위 객체이다. 자바스크립트 환경에 따라 지칭하는 이름이 다르다. 브라우저 환경 - window, self, this, frames 이 전역 객체를 가리킴 Node.js 환경 - global 전역 객체는 표준 빌트인 객체들과 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 계층적 구조 상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다. 프로토타입 상속 관계 상에서 최상위 객체라는 의미가 아니다 객체의 계층적 구조 상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다. 전역 객체의 특징 전역 객체는 개발자가 의도적으로 생성할 수 없다. 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다. 전역 객체의 프로퍼티를 참조할 때 window(global)를 생략할 수 있다. 전역 객체는 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다. 자바스크립트 실행 환경에 따라 추가적으로 프로퍼티와 메소드를 갖는다. 클라이언트 사이드 Web API, Node.js 고유의 API를 호스트 객체로 제공한다. 전역 함수는 전역 객체의 프로퍼티가 된다. var 키워드로 선언한 전역 변수와 선언하지 않는 변수에 값을 할당한 암묵적 전역 let , const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다.12345678910var foo = 1;console.log(window.foo); //1bar = 2;console.log(window.bar); //2funciton baz() { return 3;}console.log(window.baz()); //3 전역 객체는 몇가지 프로퍼티와 메소드를 가지고 있다. 전역 객체의 프로퍼티와 메소드는 전역 객체를 가리키는 식별자를 생락하여 참조/호출 할 수 있으므로 전역 변수와 전역 함수처럼 사용할 수 있다. 4.1 빌트인 전역 프로퍼티 (Built-in global property)전역 객체의 프로퍼티를 의미, 주로 애플리케이션 전역에서 사용하는 값을 제공한다. 4.1.1 InfinityInfinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다. 1console.log(window.Infinity === Infinity); //true 4.1.2 NaNNaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 갖는다.NaN 프로퍼티는 Number.NaN 프로퍼티와 같다. 4.1.3 undifinedundifined 프로퍼티는 원시 타입 undifined를 값으로 갖는다. 4.2 빌트인 전역 함수빌트인 전역 함수는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다. 4.2.1 eval문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과 값을 반환한다.eval 함수는 런타임에 자신이 호출된 기존의 스코프를 동적으로 수정한다. 4.2.2 isFinite매개변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다.매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 4.2.3 isNaN매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 변환한 후 검사를 수행한다. 4.2.4 parseFloat매개변수에 전달된 문자열을 부동소수점 숫자로 변환하여 반환한다. 4.2.5 parseInt매개변수에 전달된 문자열을 정수형 숫자로 해석하여 반환한다. 반환값은 언제나 10진수 4.2.6 encodeURI / decodeURIencodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말함URI의 하위 개념으로 URL, URN이 있다. 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미 4.2.7 encodeURIComponent / decodeURIComponentencodeURIComponent 함수은 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소 (component)를 인코딩한다.decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다. 4.3 암묵적 전역12345678var x = 10;function foo () { y = 20;}foo();console.log(x + y); // 30 foo 함수 내의 y는 선언하지 않은 식별자여서 y = 20이 실행되면 참조 에러가 발생할 것처럼 보인다. 하지만 선언하지 않는 식별자 y는 선언된 전역 변수처럼 동작한다.선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다. foo 함수가 호출되면 자바스크립트 엔진은 변수 y에 값을 할당하기 위해 먼저 스코프체인을 통해 선언된 변수인지 확인한다. foo 함수의 스코프, 전역 스코프 어디에서도 변수 y의 선언을 찾을 수 없으므로 참조에러가 발생햐아한다.하지만 자바스크립트엔진은 y = 20을 window.y = 20 으로 해석하여 전역 객체에 프로퍼티를 동적 생성한다. y는 전역 객체의 프로퍼티가 되어 마치 전역 변수가 동작한다.이러한 현상을 암묵적 전역이라 한다.y는 변수 없이 전역 객체의 프로퍼티로 추가 되었을 뿐, y는 변수가 아니다.따라서 y는 변수 호이스팅이 발생하지 않는다.delete 연산자로 삭제할 수 있다. (변수가 아니기 때문) ,전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다. 1234567891011console.log(x); undifinedconsole.log(y); ReferenceError: y is not definedvar x = 10;funciton foo () { y = 20;}foo();console.log( x + y);","link":"/2020/03/javaScript/js.built-in%20object/"},{"title":"javaScript/js.array1","text":"배열1. 배열이란? 배열은 여러 개의 값을 순차적으로 나열한 자료 구조이다. 배열이 가지고 있는 값을 요소(element)라 한다. 자바스크립트에서 값으로 인정하는 모든 것은 배열의 요소가 된다. 배열의 요소는 배열에서 자신의 위치를 나타내는 0 이상의 정수인 index를 갖는다. 이를 통해 요소에 접근할 수 있다. 배열은 요소의 개수, 즉 배열의 길이를 나타내는 length 프로퍼티를 갖는다. 배열 리터럴 또는 Array 생성자 함수로 생성할 수 있다.배열의 생성자 함수는 Array이며 배열의 프로토타입 객체는 Array.prototype. -&gt; 배열을 위한 빌트인 메소드 들을 제공한다. 배열은 객체이다. 일반 객체와는 다른 특징 구분 객체 배열 구조 프로퍼티 키와 프로퍼티 값 인덱스와 요소 값의 참조 프로퍼티 키 인덱스 값의 순서 X O length프로퍼티 X O 2. 자바스크립트의 배열희소 배열(sparse array) (자바스크립트)배열의 요소가 연속적으로 이어져 있지 않는 배열 밀집 배열 (Dense array) 일반적인 배열로 하나의 타입으로 통일되어 있으면서 서로 연속적으로 인접해 있다. 매우 효율적이며 고속으로 동작한다. 배열에 요소를 삽입하거나 삭제하는 경우, 배열 요소를 연속적으로 유지하기 위해 요소를 이동시켜야 하는 단점 자바스크립트는 일반적인 배열의 동작을 흉내낸 특수한 객체이다. 인덱스를 프로퍼티 키로 갖으며 length 프로퍼티를 갖는 특수한 객체이다. 어떤 타입의 값이라도 배열의 요소가 될 수 있다. 해시 테이블로 구현된 객체이므로 인덱스로 배열 요소에 접근하는 경우, 일반적인 배열보다 성능적인 면에서 느릴수 밖에 없는 구조적 단점 특정 요소를 탐색하거나 추가, 삭제하는 경우에는 일반적인 배열보다 빠른 성능 3. length 프로퍼티와 희소 배열 length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 정수를 값으로 갖는다. length 프로퍼티의 값은 빈 배열일 경우 0이며, 빈 배열이 아닐 경우 가장 큰 인덱스에 +1 이다. 12[].length //0[1, 2, 3].length // 3 length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신된다. length 프로퍼티의 값은 임의의 숫자 값을 명시적으로 할당할 수도 있다. length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다. 큰 숫자 값을 할당하는 경우, 프로퍼티 값은 변경되지만 실제로 배열의 길이가 늘어나지 않는다. 값 없이 비어있는 요소를 위해 메모리 공간을 확보하지 않으며 빈 요소를 생성하지 않는다.1234const arr = [1, 2];arr.length = 4;console.log(arr.length); // 4;console.log(arr); [ 1, 2, empty x 2]; //empty는 실제로 추가된 배열의 요소가 아니다. 이처럼 배열의 요소가 연속적으로 위치하지 않고 일부가 비어있는 배열을 희소 배열이라 한다.희소 배열의 length는 배열의 실제 요소 개수보다 언제나 크다.12345const sparse = [, 2, , 4]; //희소 배열console.log(sparse.length); //4console.log(sparse); // [empty, 2, empty, 4]// 배열 sparse에는 인덱스 0, 2인 요소가 존재하지 않는다. 자바스크립트에서 허용하더라도, 희소 배열은 사용하지 않는 것이 좋다. 4. 배열 생성4.1 배열 리터럴 0개 이상의 요소를 쉼표로 구분하여 대괄호를 묶는다. 프로퍼티 이름이 없고 값만 존재한다. 존재하지않는 요소(프로퍼티 키)를 참조할 경우 undifined를 반환한다. 4.2 Array 생성자 함수 Array 생성자 함수를 통해 배열을 생성할 수 있다. Array 생성자 함수는 전달된 인수 개수에 따라 다르게 동작한다. 전달된 인수가 1개이고 숫자인 경우, 인수를 length 프로퍼티의 값으로 갖는 배열을 생성한다.123const arr = new Array(10);const.log(arr); // [empty x 10]const.log(arr.length); // 10 전달된 인수가 없는 경우, 빈 배열을 생성한다. [] 전달된 인수가 2개 이상이거나 숫자가 아닌 경우, 인수를 요소로 갖는 배열을 생성한다. new 연산자와 함께 호출하지 않아도 배열을 생성하는 생성자 함수로 동작한다.Array 생성자 함수 내부에서 new.target을 확인하기 때문이다. 4.3 Array.of ES6에서 도입. 전달된 인수를 요소로 갖는 배열을 생성한다. 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다 (Array 생성자 함수랑 다름) 4.4 Array.from ES6에서 도입. 유사 배열 객체 또는 이터러블 객체를 변환하여 새로운 배열을 생성한다.1234567// 문자열은 이터러블const arr1 = Array.from('hello');console.log(arr1); //['h', 'e', 'l', 'l', 'o']//// 유사 배열 객체를 새로운 배열로 변환하여 반환한다.const arr2 = Array.from({ length: 2, 0: 'a', 1: 'b'});console.log(arr2); // ['a', 'b'] Array.from을 사용하여 두번째 인수로 전달한 함수를 통해 값을 만들면서 요소를 채울 수 있다.두번째 인수로 전달한 함수는 첫번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달받아 새로운 요소를 생성할 수 있다.123const arr3 = Array.from({ length: 5 }, function (v, i) { return i; });console.log(arr3); // [0, 1, 2, 3, 4]//두번째 인수로 배열의 모든 요소에 대해 호출할 함수를 전달 할 수 있다. 5. 배열 요소의 참조 배열 요소를 참조할 떄는 대괄호 []표기법을 사용한다. 안에는 인덱스가 와야한다. 존재하지 않는 요소에 접근하면 undifined 반환된다. 6. 배열 요소의 추가와 갱신 요소를 동적으로 추가할 수 있다. length 프로퍼티 값은 자동 갱신된다. length 프로퍼티 값보다 큰 인덱스로 요소를 추가하면 희소배열이 된다. 이미 요소가 존재하는 요소에 값을 재할당하면 요소값이 갱신된다. 정수 이외의 값을 인덱스처럼 사용하면 요소가 생성되는 것이 아니라 프로퍼티가 생성된다.이때 추가된 프로퍼티는 length 프로퍼티 값에 영향을 주지 않는다. 7. 배열 요소의 삭제 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다. 요소를 삭제하더라도 length 프로퍼티 값은 변하지 않아서 희소배열을 만든다. 안쓰는게 좋다. 8. 배열 메소드 (accessor method) 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메소드 (accessor method) 원본 배열을직접 변경하는 메소드 (mutator method) 8.1 Array.isArray Array 생성자 함수의 정적 메소드 (Array.of, Array.from 또한 정적 메소드) Array.isArray 주어진 인수가 배열이면 true, 아니면 false 8.2 Array.prototype.indexOf원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다. 중복되는 요소가 있는 경우, 첫번째 인덱스를 반환한다. 해당하는 요소가 없는 경우, -1을 반환한다.1234const arr = [1, 2, 2, 4];arr.indexOf(2); // 1 요소 2를 검색하여 첫번째 인덱스를 반환arr.indexOf(4); // -1arr.IndexOf(2, 2); //두번째 인수는 검색을 시작할 인덱스이다. indexOf 메소드는 배열에 요소가 존재하는지 확인할 때 유용하다. 123456789101112131415const appleSeries = ['macbook', 'iphone', 'ipad', 'imac'];if (appleSeries.indexOf('magicMouse') === -1) { // 배열에 'magicMouse' 가 있는지 확인 appleSeries.push('magicMouse'); // 존재하지 않으면 요소를 추가}console.log(appleSeries);// ES7에서 새롭게 도입된 Array.prototype.includes 메소드가 더 가독성이 좋다.const animals = ['cat', 'dog', 'pig'];if (!animals.includes('snake')) { animals.push('snake');}console.log(animals); 결과값 -1을 비교해봐야하고, 배열에 NaN이 포함되어있는지 확인 불가 ( 단점 ) 8.3 Array.prototype.push push 메소드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다. push 메소드는 원본 배열을 직접 변경한다.123456// 또한 push 메소드는 원본 배열을 직접 변경하는 부수 효과가 있다.// ES6의 스프레드 문법을 사용하는 것이 좋다.const arr3 = [1, 2];const newArr = [... arr3, 3];console.log(newArr); 8.4 Array.prototype.pop pop 메소드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undifined를 반환한다. 원본 배열을 직접 변경한다.12345const arr4 = [1, 2];let res = arr4.pop();console.log(res);console.log(arr4); 8.5 Array.prototype.unshift 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다. unshift 메소드는 원본 배열을 직접 변경한다.1234567891011const arra = [1, 2];let a = arra.unshift(3, 4);console.log(a); // 변경된 length 값을 반환console.log(arra);// 스프레드 문법을 쓰는 것이 더 좋다.const arra1 = [1, 2];const newArra = [3, ...arra1];console.log(newArra); 8.6 Array.prototype.shift 원본 배열에서 첫번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undifined를 반호나한다. shift 메소드는 원본 배열을 직접 변경한다.12345const arra2 = [1, 2];let b = arra2.shift();console.log(b);console.log(arra2); 8.7 Array.prototype.concat 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가한다. 원본 배열은 변경되지 않는다.12345678910111213141516const array1 = [1, 2];const array2 = [3, 4];let result3 = array1.concat(array2);console.log(result1);result1 = array1.concat(3);console.log(result1);result1 = array1.concat(array2, 5); // 두번째 값은 마지막 요소로 추가console.log(result1);console.log(array1);// concat 메소드는 ES6의 스프레드 문법으로 대체 가능하다result2 = [...[1, 2], ...[3, 4]];console.log(result2); push , unshift 메소드 - 원본 배열을 직접 변경 (반드시 변수에 할당해야함) concat 메소드 - 새로운 배열을 반환 (반환값을 반드시 변수에 할당 받아야함) 스프레드 문법을 쓰자..! 8.8 Array.prototype.splice 원본 배열의 중간에 요소를 추가하거나 제거하는 경우 사용 3개의 매개변수가 있으며 원본 배열을 직접 변경한다. start - 요소를 제거하기 시작할 인덱스. start만을 지정하면 start부터 모든 요소를제거한다. start가 음수인 경우, 배열의 끝에서의 인덱스를 나타낸다. -1이면 마지막 요소, -n이면 마지막에서 n번째 요소를 가리킨다. deleteCount - start부터 제거할 요소의 개수. 0인 경우, 요소제거X items - 제거한 위치에 삽입될 요소들의 목록, 생략가능 (옵션) 생략할 경우 제거만 한다.123456789101112const arr = [1, 2, 3, 4];const result = arr.splice(1, 2, 20, 30);console.log(result); // [2, 3] 제거한 요소가 배열로 반환된다.console.log(arr); // [1, 20 , 30, 4]const result = arr.splice(1, 0, 100);console.log(arr); // [1, 100 ,2 ,3, 4]console.log(reusult); // []const result = arr.splice(1);console.log(arr); //[1]console.log(result); //[2, 3, 4] 8.9 Array.prototype.slice 인수로 전달된 범위의 요소들을 복사하여 반환한다. 원본 배열은 변경되지 않는다. 2개의 매개변수를 갖는다. start - 복사를 시작할 인덱스. 음수인 경우, 배열의 끝에서 인덱스를 나타낸다.slice(-2)는 배열의 마지막 2개의 요소를 반환한다. end - 복사를 종료할 인덱스. 이 인덱스에 해당하는 요소는 복사되지않는다. 옵션이며 기본값은 length 값이다. 인수를 모두 생략하면 원본 배열의 새로운 복사본을 생성하여 반환한다. 1234567891011const arr = [1, 2, 3];let result = arr.slice(0, 1);console.log(result); //[1]console.log(arr); //[1, 2, 3]let result = arr.slice(-1);console.log(result) // [3]const copy = arr.slice();console.log(copy); //[1, 2, 3]console.log(copy === arr); // false slice 메소드를 이용하여 arguments 같은 유사배열객체를 배열로 변환할 수 있다. 8.10 Array.prototype.join 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 값, 즉 구분자(separator)로연결한 문자열을 반환한다. 구분자는 생략가능하며 기본구분자는 , 이다12345678const arr = [ 1, 2, 3, 4];let result = arr.join();console.log(result); // '1,2,3,4'result = arr.join('');console.log(result); // '1234'result = arr.join(':');console.log(result); // '1:2:3:4' 8.11 Array.prototype.reverse 원본 배열의 요소 순서를 반대로 변경한다. 반환값은 변경된 배열이다.1234const arr = [1, 2, 3];const result = arr.reverse();console.log(arr); // [3, 2, 1]console.log(result); // [3, 2, 1] 8.12 Array.prototype.fill ES6에서 새롭게 도입됌 인수로 전달받은 값을 요소로 배열의 처음부터 끝까지 채운다. 원본 배열이 변경된다. 첫번째 인수 - 요소를 변경할 값 두번째 인수 - 요소 채우기를 시작할 인덱스 세번째 인수 - 채우기를 멈출 인덱스 (이 인덱스는 채우기에 포함되지 않음)12345678910const arr = [1, 2, 3];arr.fill(0);console.log(arr); //[0, 0, 0]arr.fill(0, 1); // 0을 요소로 인덱스 1부터 채운다.console.log(arr); //[1, 0, 0]const arr = [1, 2, 3, 4, 5]arr.fill(0, 1, 3);console.log(arr); //[1, 0, 0, 4, 5] 모든 요소를 하나의 값만으로 채울 수 밖에 없는 단점이 있다. 8.13 Array.prototype.includes ES7에서 새롭게 도입 배열 내에 특정 요소가 포함되어 있는지 확인하여 boolean값을 반환한다. 첫번째 인수로 검색할 대상을 지정한다. 두번째 인수로 검색을 시작할 인덱스를 전달할 수 있다. 생략할 경우, 기본값은 0음수를 전달하면 length와 음수 인덱스를 합산하여 (length+index)검색 시작 인덱스를 설정한다.1234567891011const arr = [1, 2, 3];let result = arr.includes(2);console.log(result); // trueresult =arr.includes(100);console.log(result); //false//result = arr.includes(1, 1); // 1이 포함되어 있는지 인덱스 1부터 검색 console.log(result); // falseresult = arr.includes(3, -1); // 배열에 요소 3이 포함되어 있는지 인덱스 2부터 확인 (arr.length - 1)console.log(result); //true 8.14 Array.prototype.flat ES10에서 새롭게 도입됌 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다. 인수로 중첩 배열을 평탄화할 깊이를 전달할 수 있다. 기본값은 1, Infinity를 전달하면 중첩 배열 모두를 평탄화한다.123console.log(1, [2, 3, 4, 5]].flat()); //[1, 2, 3, 4, 5]console.log(1, [2, [3, [4, 5]]].flat(2)); //[1, 2, 3, [4, 5]]console.log(1, [2, 3, 4, 5]].flat(Infinity)); //[1, 2, 3, 4, 5]","link":"/2020/03/javaScript/js.array1/"},{"title":"javaScript/js.REST API","text":"REST API1. REST API의 구성 구성 요소 내용 표현 방법 자원(Resource) 자원 HTTP URI 행위(Verb) 자원에 대한 행위 HTTP 요청 메소드 표현(Representations) 자원에 대한 행위의 구체적 내용 HTTP 페이로드 GET 요청12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script&gt; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 // todos 리소스에서 모든 todo를 취득 (index) xhr.open('GET', '/todos'); // HTTP 요청 전송 xhr.send(); // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다. xhr.onload = () =&gt; { // status는 response 상태 코드를 반환 : 200 =&gt; 정상응답 if (xhr.status === 200) { document.querySelector('pre').textContent = xhr.response; } else { console.error('Error', xhr.status, xhr.statusText); } }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; POST 요청1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script&gt; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 // todos 리소스에서 모든 todo를 취득 xhr.open('POST', '/todos'); // 요청 몸체에 담아 서버로 전송할 페이로드의 MIME-type을 지정 xhr.setRequestHeader('content-type', 'application/json'); // HTTP 요청 전송 // 새로운 todo를 생성하기 위해 페이로드가 필요 xhr.send(JSON.stringify({ id: 4, content: 'Angular', completed: false})); // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다. xhr.onload = () =&gt; { // status는 response 상태 코드를 반환 : 200 =&gt; 정상응답 if (xhr.status === 200 || xhr.status === 201) { document.querySelector('pre').textContent = xhr.response; } else { console.error('Error', xhr.status, xhr.statusText); } }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; PUT 요청PUT은 특정 리소스의 저네를 교체할 때 사용한다.(todos 리소스에서 id를 사용하여 todo를 특정하여 id를 제외한 리소스 전체를 교체한다.) 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script&gt; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 // todos 리소스에서 id를 사용하여 todo를 특정하여 id를 제외한 리소스 전체를 교체 xhr.open('PUT', '/todo/4'); // 요청 몸체에 담아 서버로 전송할 페이로드의 MIME-type을 지정 xhr.setRequestHeader('content-type', 'application/json'); // HTTP 요청 전송 // 리소스 전체를 교체하기 위해 페이로드가 필요 xhr.send(JSON.stringify({ id: 4, content: 'Angular', completed: false})); // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다. xhr.onload = () =&gt; { // status는 response 상태 코드를 반환 : 200 =&gt; 정상응답 if (xhr.status === 200 || xhr.status === 201) { document.querySelector('pre').textContent = xhr.response; } else { console.error('Error', xhr.status, xhr.statusText); } }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; PATCH 요청1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script&gt; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 // todos 리소스에서 id를 사용하여 todo를 특정하여 completed만을 수정 xhr.open('PATCH', '/todo/4'); // 요청 몸체에 담아 서버로 전송할 페이로드의 MIME-type을 지정 xhr.setRequestHeader('content-type', 'application/json'); // HTTP 요청 전송 // 리소스 수정하기 위해 페이로드가 필요 xhr.send(JSON.stringify({ id: 4, content: 'Angular', completed: false})); // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다. xhr.onload = () =&gt; { // status는 response 상태 코드를 반환 : 200 =&gt; 정상응답 if (xhr.status === 200 || xhr.status === 201) { document.querySelector('pre').textContent = xhr.response; } else { console.error('Error', xhr.status, xhr.statusText); } }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; DELETE 요청(todos 리소스에서 id를 사용하여 todo를 삭제) 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script&gt; // XMLHttpRequest 객체 생성 const xhr = new XMLHttpRequest(); // HTTP 요청 초기화 // todos 리소스에서 id를 사용하여 todo를 삭제 xhr.open('DELETE', '/todo/4'); // HTTP 요청 전송 // 리소스 전체를 교체하기 위해 페이로드가 필요 xhr.send(); // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다. xhr.onload = () =&gt; { // status는 response 상태 코드를 반환 : 200 =&gt; 정상응답 if (xhr.status === 200) { document.querySelector('pre').textContent = xhr.response; } else { console.error('Error', xhr.status, xhr.statusText); } }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/javaScript/js.REST%20API/"},{"title":"javaScript/js.class","text":"클래스클래스는 class 키워드를 사용하여 정의한다.클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용하는 것이 일반적이다.파스칼 케이스를 사용하지 않아도 에러가 발생하지 않는다. 클래스 vs 생성자 함수 (생성자함수의 경우) 클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발생한다. (일반함수로서 호출) 상속을 지원하는 extends, super 키워드를 제공한다 호이스팅이 발생하지 않는 것처럼 동작한다. (함수 선언문으로 정의되면 함수 호이스팅 발생) 모든 코드는 암묵적으로 strict 모드가 지정, 해지 불가 (strict모드 지정안됌) 클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 열거되지 않는다. 1. 클래스의 정의 class 키워드를 사용하여 정의한다. 클래스 이름은 파스칼 케이스로, 물론 사용하지 않아도 에러 발생 없음 일반적이지는 않지만, 표현식으로 클래스를 정의할 수도 있다. (익명, 기명) 클래스는 일급 객체이다 (클래스 = 함수 = 객체) 클래스 몸체에는 0개 이상의 메소드만을 선언할 수 있다. constructor, 프로토타입 메소드, 정적 메소드 3가지 123456789101112131415161718class Person { //클래스 선언문 constructor(name) { // 생성자 constructor this.name = name; } sayHi() { //프로토타입 메소드 console.log(`Hi! ${this.name}`); } static sayHello() { //정적 메소드 console.log('hello'); }} const me = new Person('jung'); //인스턴스 생성 console.log(me.name); // jung me.sayHi(); // Hi! jung Person.sayHello(); //hello 2. 클래스 호이스팅 클래스는 클래스 정의 이전에 참조할 수 없다. 호이스팅이 발생하지 않는 것처럼 보인다 ( = let, const로 선언한 변수처럼 호이스팅 함) 클래스 표현식으로 정의한 클래스는 변수 호이스팅을 따른다. 3. 인스턴스 생성 클래스는 인스턴스를 생성하는 생성자 함수이며, new 연산자와 함께 호출되어 인스턴스를 생성한다. 반드시 new 연산자와 함께 호출해야 한다. 없이 호출하면 TypeError 클래스 표현식으로 정의된 클래스의 경우, 클래스를 가리키는 식별자를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다. 4. 메소드4.1 constructor constructor는 인스턴스를 생성하고 초기화하기 위한 특수 메소드. 이름을 변경할 수 없다. constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다. 메소드로 해석안되고, 클래스가 평가되어 생상한 함수 객체 코드의 일부가 된다.클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다. 2개 이상의 constructor를 포함하면 문법에러가 발생한다. 생략할 수 있다. 클래스에 디폴트 constructor가 암묵적으로 정의된다. (빈객체 생성) 12345class Person {}const me = new Person();console.log(me); // Person {} 빈객체 생성 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다. 인스턴스를 초기화하려면 constructor를 생략해서는 안된다. this가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 객체가 반환된다. 명시적으로 반환값이 원시값이면 원시값은 무시되고 암묵적으로 this가 반환된다. return문은 반드시 생략해야한다. 4.2 프로토타입 메소드 클래스의 prototype 프로퍼티에 메소드를 추가하지 않아도 기본적으로 프로토타입 메소드가 된다. 클래스가 생성한 인스턴스는 프로토타입 체인에 속한다 4.3 정적 메소드 (static) 정적 메소드는 인스턴스를 생성하지 않아도 호출할 수 있는 메소드를 말한다. 클래스 몸체에서 정의한 메소드에 static 키워드를 붙이면 정적 메소드가 된다. 정적 메소드는 클래스 자신의 메소드가 된다. 4.4 정적 메소드 vs 프로토타입 메소드 s 프로토타입 체인이 다르다. 정적 메소드 -&gt; 클래스로 호출 , 프로토타입 메소드 -&gt; 인스턴스로 호출 정적 메소드는 인스턴스 프로퍼티를 참조할 수 없고, 프로토타입 메소드는 가능하다 4.5 클래스에서 정의한 메소드의 특징 function 키워드를 생략한 메소드 축약 표현을 사용 클래스에 메소드를 정의할 때는 콤마가 필요 없다. 암묵적으로 strict 모드가 실행된다. for…in문 Object.keys 메소드 등으로 열거할 수 없다. [[Enumerable]] 값이 false 내부 메소드 [[Construct]]를 갖지 않는 non-constructor, 따라서 new 연산자와 함께 호출할 수 없다. 5. 클래스의 인스턴스 생성 과정 new 연산자와 함께 클래스를 호출하면 클래스의 내부 메소드 [[Construct]] 호출클래스는 new 연산자 없이 호출할 수 없다. 1. 인스턴스 생성과 this 바인딩2. 인스턴스 초기화3. 프로토타입 / 정적 메소드 추가4. 인스턴스 반환6. 프로퍼티6.1 인스턴스 프로퍼티 인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다. constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다. 클래스가 암묵적으로 생성한 빈 객체, 인스턴스에 프로퍼티가 추가되어 인스턴스가 초기화된다. 6.2 접근자 프로퍼티 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 뎅터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다. 클래스의 메소드는 기본적으로 프로토타입 메소드가 된다. 클래스 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다. 6.3 클래스 필드 정의 제안 클래스 필드는 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다. 클래스 몸체에는 메소드 만을 선언할 수 있다. 클래스 몸체에 클래스 필드를 선언하면 문법 에러가 발생한다. 클래스 몸체에서 클래스 필드를 정의하는 경우, this에 클래스 필드를 바인딩해서는 안된다. this는 클래스의 constructor와 메소드 내에서만 유효하다. 클래스 필드에 초기값을 할당하지 않으면 undifined를 갖는다. 6.4 private 필드 정의 제안 constructor 내부에서 this를 통해 정의한 인스턴스 프로퍼티는 은서튼스를 통해 클래스 외부에서 언제나 참조할 수 있다. (public) private 필드의 선두에는 #을 붙여준다. private 필드를 참조할 때도 #을 붙여주어야 한다.12345678910class Person { #name = ''; constructor(name) { this.#name = name; }}const me = new Person('jung;);console.log(me.#name); 접근 가능성 public private 클래스 내부 ◯ ◯ 자식 클래스 내부 ◯ X 클래스 인스턴스를 통한 접근 ◯ X private 필드는 클래스 내부에서만 참조할 수 있다. 부모 클래스를 포함한 클래스 외부에서 private 필드에 직접 접근할 수 있는 방법은 없다. 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다. 123456789101112131415class Person { #_name = ''; //private 필드 정의 constructor(name) { this.#_name = name; } get name () { // 접근자 프로퍼티 (name) return this.#_name.trim(); }}const me = new Person('jung');console.log(me.name); //'jung' private 필드는 반드시 클래스 몸체에서 정의해야 한다. constructor에 정의하면 에러가 발생한다. 6.5 static 필드 정의 제안-static 필드를 정의 할수 없었지만, static public 필드, static private 메소드를 정의할 수 있는 새로운 표준 사양인 “Static class features”이 TC39 프로세스의 stage3에 제안되어 있다. 1234567891011class MyMath { static PI = 22/7; //static public 필드 정의 static #num = 10; //static private 필드 정의 static increment() { //static 메소드 return ++MyMath.#num; }}console.log(MyMath.PI); // 3.14~~~console.log(MyMath.increment()); //11 7. 상속에 의한 클래스 확장7.1 클래스 상속과 생성자 함수 상속 프로토타입과 다른점이 있다. 상속에 의한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장하여 정의 하는 것이다. 상속을 통해 기존의 클래스를 확장할 수 있는 문법이 기본적으로 제공(extends) 1234567891011121314151617class Animal { constructor(age, weight) { this.age = age; this.weight = weight; } eat() { return ' eat'; } move() { return 'move'; }}class Bird extends Animal { fly() { return 'fly'; }}const bird = new Bird(1, 5);console.log(bird); //Bird{age: 1, weight: 5} 7.2 extends 키워드 상속을 통해 클래스를 확정하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다. 상속을 통해 확장된 클래스를 서브 클래스라 부르고 , 서브 클래스에게 상속된 클래스를 수퍼 클래스라 부른다. 서브 클래스 = 파생 클래스,자식 클래스. 수퍼 클래스 = 베이스 클래스, 부모 클래스 수퍼 클래스와 서브클래스는 인스턴스의 프로로타입 체인뿐만 아니라, 클래스 간의 프로토타입 체인도 생성한다. 프로토타입 메소드, 정적 메소드 모두 상속 가능하다. 7.3 동적 상속 extends 키워드는 생성자 함수를 상속받아 클래스를 확장할 수도 있다. extends 키워드는 앞에는 반드시 클래스가 와야한다. extends 키워드 다음에는 클래스뿐만 아니라 [[Construct]]내부 메소드를 갖는 함수 객체를 반환하는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다. 7.5 super 키워드 super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다. super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다. super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다. super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스 또는 함수에서 호출하면 에러를 발생시킨다. super 참조. 메소드 내에서 super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다. 서브 클래스의 프로토타입 메소드 내에서 super.prop는 수퍼 클래스의 프로토타입 메소드 prop를 가 리킨다. 서브 클래스의 정적 메소드 내에서 super.prop는 수퍼 클래스의 정적 메소드 prop를 가리킨다. 7.6 상속 클래스의 인스턴스 생성 과정1. 서브 클래스의 super 호출2. 수퍼 클래스의 인스턴스 생성과 this 바인딩3. 수퍼 클래스의 인스턴스 초기화4. 수퍼 클래스의 프로토타입, 정적 메소드 추가5. 서브 클래스 constructor로의 복귀와 this 바인딩6. 서브 클래스의 인스턴스 초기화7. 인스턴스 반환7.7 네이티브 생성자 함수 확장extends 키워드 다음에는 클래스뿐만 아니라 [[Construct]] 내부 메소드를 갖는 함수 객체를 바환하는 모든 표현식을 사용할 수 있다. (String, Number, Array)","link":"/2020/03/javaScript/js.class/"},{"title":"javaScript/js.closure","text":"클로저(closure)클로저는 자바스크립트 고유의 개념이 아니므로 ECMAScript 사양에 클로저의 정의가 등장하지 않는다.클로저는 함수와 그 함수가 선언된 렉시컬 환경(Lexical environment)과의 조합이다. 1. 렉시컬 스코프자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프라)라한다. 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 12345678910111213const x = 1;function foo() { const x = 10; bar ();}function bar() { console.log(x);}foo(); // 1bar(); // 1 foo, bar 함수는 모두 전역에서 정의된 전역 함수 두 함수의 상위 스코프는 전역이다. 스코프의 실체는 실행 컨텍스트의 렉시컬 환경이다. 렉시컬 환경은 자신의 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)를 통해 상위 렉시컬 환경과 연결된다. 이것이 스코프 체인 함수의 상위 스코프를 결정한다? -&gt; 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다. 2. 함수 객체의 내부 슬롯 [[Environment]] 함수는 자신의 내부슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다. 함수 정의가 평가되어 함수 객체를 생성할 때, 자신이 정의된 위치에 의해 결정된 상위 스코프의 참조를 함수 객체 자신의 내부슬롯 [[Environment]]에 저장한다. 이때 자신의 내부슬롯 [[Environment]]에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다. 함수 객체의 내부슬롯 [[Environment]]에 저장한 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프이다.자신이 호출되었을 때 생성될 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장될 참조값이다. 함수 객체는 내부슬롯 [[Environment]]에 저장할 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다. 3. 클로저와 렉시컬 환경123456789101112const x = 1;function outer() { const x = 10; const inner = function () { console.log(x); }; return inner;}const innerFunc = outer();innerFUnc(); //10 outer 함수를 호출하면 outer는 중첩함수 inner 함수를 반환하고 생명주기를 마감(outer의 호출이 종료하면 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거) 이때 함수 outer의 지역 변수 x와 변수값 10을 저장하고 있는 함수 outer 실행컨텍스트가 제거 되었으므로 함수 outer의 지역 변수 x 또한 생명 주기를 마감 함수 outer의 지역 변수 x는 더이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법이 없어보임 그러나 코드의 실행 결과는 x의 값인 10 이러한 함수를 클로저라..한다.. 자신의 상위 스코프를 기억하고 있기 때문이다. inner 함수는 자신이 평가될 때 자신이 정의된 위치에 의해 결정된 상위스코프를[[Environment]] 내부슬롯에 저장한다. 이때 저장된 상위 스코프는 함수가 존재하는 한 유지된다. outer 함수의 렉시컬 환경은 inner 함수의 [[Environment]] 내부슬롯에 의해 참조되고 있고 inner 함수는 전역 변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않는다. (가비지 컬렉터는 참조되고 있는 메모리공간을 해제하지않는다.) 4. 클로저의 활용클로저는 상태를 안전하게 유지하기 위해 사용한다. 상태가 의도치 않게 변경되지 않도록 안전하게 은닉한다.이전 상태를 기억하다가 상태가 변경되면 최신 상태(state)를 유지한다. ….","link":"/2020/03/javaScript/js.closure/"},{"title":"javaScript/js.constructor","text":"생성자 함수에 의한 객체 생성1. Object 생성자 함수 new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 생성자(constructor) 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다. new 연산자와 함께 생성자 함수를 호출하지 않으면, 일반 함수로 동작한다. 2. 생성자 함수2.1 객체 리터럴에 의한 객체 생성 방식의 문제점 객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 동일한 프로퍼티를 갖는 객체를 여러개 생성해야 하는 경우 비효율적이다. 객체는 프로퍼티를 통해 객체의 고유상태를 표현,메소드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작을 표현한다. 2.2 생성자 함수에 의한 객체 생성 방식의 장점 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성한다. 123456789101112131415// 생성자 함수function Circle(radius) { this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스의 생성const circle1 = new Circle(5); //반지름이 5인 Circle 객체 생성const circle2 = new Circle(10); //반지름이 10인 Circle 객체 생성 console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 thisthis는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. 함수 호출방식 this가 가리키는 값 일반 함수로서 호출 전역 객체 메소드로서 호출 메소드를 호출한 객체 생성자 함수로서 호출 생성자 함수가 (미래에)생성할 인스턴스 123const circle3 = Circle(15);console.log(circle3); //undefined// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undifined를 반환한다. new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않음 -&gt; 일반함수로 동작 일반함수는 반환문이 없으면 암묵적으로 undefined를 반환한다. 2.3 내부 메소드 [[Call]], [[Construct]] 내부 메소드 [[Call]]을 갖는 함수 객체를 callable (호출할 수 있는 객체) 내부 메소드 [[Construct]]을 갖는 함수 객체를 construtor(생성자로서 호출할 수 있는 객체) [[Construct]]을 갖지 않는 함수 객체를 non-constructor 함수 객체는 반드시 callable, 그리고 constructor 일수도 있고, non-constructor일 수도 있다. 2.4 Constructor 와 non-construct의 구분 자바스크립트 엔진은 함수를 생성할 때, FunctionCreate라는 추상연산을 사용한다.추상연산은 ECMA 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다. 추상연산은 함수 정의가 평가될 때 호출된다. 함수 정의 방식에 따라 FunctionCreate의 첫번째 매개변수 kind에 함수의 종류를 나타내는 문자열이 전달된다. 구분 함수의 종류를 나타내는 문자열 일반 함수 정의를 평가할 때 Normal 화살표 함수 정의를 평가할 때 Arrow 메소드 정의를 평가할 때 Method 함수로 정의된 함수만 constructor Arrow, Method인 함수는 non- constructor non-construtor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다. 2.5 생성자 함수의 인스턴스 생성 과정 생성자 함수의 역할 - 인스턴스를 생성하는 것, 생성된 인스턴스를 초기화하는 것 인스턴스 초기화 - 인스턴스 프로퍼티 추가 및 초기값 할당 생성자 함수가 인스턴스를 생성하는 것은 필수, 초기화하는 것은 옵션 생성과정 인스턴스 생성과 this 바인딩암묵적으로 빈 객체가 생성된다. (생성자 함수가 생성한 인스턴스)인스턴스는 this에 바인딩된다. 인스턴스 초기화생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스 초기화this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값 할당 인스턴스 반환생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고, return문에 명시한 객체가 반환된다.명시적으로 원시값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다. 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 return문을 반드시 생략해야 한다. 2.6 new 연산자 new 연산자와 함께 호출하는 함수는 constructor여야 한다. new 연산자 없이 생성자 함수를 호출하면 일반함수로 호출된다. [[Call]] 123456789101112131415//생성자 함수function Circle(radius) { this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}//new 연산자 없이 생성자 함수를 호출하면 일반 함수로서 호출const circle = Circle(5);console.log(circle); //undifined//일반 함수 내부의 this는 전역 객체 window를 가리킨다.console.log(radius); //5console.log(getDiameter()); // 10 circle 함수를 일반적인 함수로 호출하면 함수 내부의 this는 전역 객체 window를 가리킨다. radius 프로퍼티, getDiameter 메소드는 전역 객체가 된다. 2.7 new.target new 연산자 없이 생성자 함수를 호출하는 것을 방지하기 위해, ES6에서 new.target 지원 new.target은 this와 유사하게 모든 함수내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. IE는 지원하지 않는다. 함수 내부에서 new.target을 사용하면 new 연산자와 함께 함수가 호출되었는지 확인 가능 new 연산자 없이 호출된 함수 내부의 new.target은 undifined new.target을 사용할 수 없는 상황이면 스코프 세이프 생성자 패턴을 사용","link":"/2020/03/javaScript/js.constructor/"},{"title":"javaScript/js.dataType","text":"데이터 타입 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 원시타입 (primitive type) 숫자(number): 숫자, 정수와 실수 구분없이 하나의 숫자 타입만 존재 문자열(string): 문자열 불리언(boolean): 논리적 true, false undefined: var 키워드로 선언된 변수에 암묵적으로 할당되는 값 null: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 symbol: 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용 객체타입 (object/reference type) 객체, 함수, 배열 등 number type 모두 실수로 처리 Infinity, -Infinity, NaN (not-a-number) string type 따움표로 텍스트를 감싼다. (키워드나 식별자와 같은 토큰과 구분하기 위해) 템플릿 리터럴 ES6부터 새로 도입된 문자열 표기법 런타임에 일반 문자열로 변환되어 처리된다. 따옴표 대신 백틱(`)을 사용한다. boolean type 논리적 참, 거짓을 나타내는 true, false undefined type 선언 이후 명시적으로 값을 할당하지 않는 변수는 자바스크립트 엔진의 암묵적 초기화에 의해 undefined 값을 가진다. 선언은 되었지만 아직 값을 할당하지 않는 변수에 접근하면 undefined가 반환 null type 변수에 값이 없다는 것을 의도적으로 명시할 때 사용(의도적 부재 intentional absence) 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 뜻 symbol type (ES6에 추가) 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다.프로퍼티 키(property key)란? 생성된 심볼 값은 노출되지 않으며 다른 값과 절대 중복되지 않는 값이다. object type 다양한 타입의 값들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 객체는 변경 가능한 값(mutable value)이다. 데이터 타입의 필요성 데이터 타입이 필요한 이유 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 떄 한번에 읽어들여야할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해","link":"/2020/02/javaScript/js.dataType/"},{"title":"javaScript/js.firstClassObject","text":"함수와 일급 객체1. 일급 객체 (first-class object) 무명의 리터럴로 생성할 수 있다. (런타임에 생성 가능) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개 변수에 전달할 수 있다. 함수의 결과값으로 반환할 수 있다. 함수는 === 일급객체 일급객체인 함수는 객체와 동일하게 사용할 수 있다. 객체 = 값, 함수 = 값 함수는 값을 사용할 수 있는 곳 어디서든지 리터럴로 정의할 수 있으며, 런타임에함수 객체로 평가 된다. 고유 프로퍼티를 갖는 것, 호출할 수 있는 것을 제외하면 일반객체와 동일하다. 일반 객체처럼 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수 있다. (고차함수) 고유 프로퍼티(데이터) (arguments, caller, length, name, prototype) 2. 함수 객체의 프로퍼티2.1 arguments 프로퍼티 함수 객체의 arguments 프로퍼티 값은 arguments 객체 함수 호출시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다. 외부에서는 사용 불가 함수 호출시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고, undefined로 초기화된 이후 인수가 할당된다. 123456789function abc(x, y) { console.log(arguments); return x + y;}console.log(abc()); //NaNconsole.log(abc(1)); //NaNconsole.log(abc(1, 2)); //3console.log(abc(1, 2, 3)); //3 argunmets 객체는 인수를 프로퍼티 값으로 소유하며, 프로퍼티 키는 인수의 순서를 나타낸다. length 프로퍼티는 인수의 개수를 가리킨다. arguments 객체는 매개변수 개수를 확정할 수 없는 가변인자 함수를 구현할 때 유용하다. 123456789101112function sum() { let res = 0;}for (let i = 0; i &lt; arguments.length; i++) { res += arguments[i];}return res;console.log(sum()); //0console.log(sum(1, 2)); //3console.log(sum(1, 2, 3)); //6 arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌유사배열객체(array-like object)이다. 유사 배열 객체 - length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체 유사 배열 객체는 배열이 아니므로 배열 메소드를 사용할 경우 에러가 발생한다. 배열 메소드를 사용하려면 Funcion.prototype.call, function.prototype.apply 를 사용해 간접 호출해야 한다. (번거로움) 대응책으로 ES6부터 Rest parameter 도입 2.2 caller 프로퍼티 ECMA 스펙에 포함되지 않은 비표준 프로퍼티 함수 자신을 호출한 함수를 가리킨다. 2.3 lengh 프로퍼티 함수 정의 시 선언한 매개변수의 개수를 가리킨다. arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다. arguments 객체의 length 프로퍼티는 인자(argument)의 개수를 가리키고,함수 객체의 length 프로퍼티는 매개변수(parameter)의 개수를 가리킨다. 2.4 name 프로퍼티 함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. ES6에서 정식 표준이 되었다. 익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다. 함수를 호출할 때는 함수 객체를 가리키는 변수 이름으로 호출한다. 2.5 proto 접근자 프로퍼티 모든 객체는 [[Prototype]]이라는 내부 슬롯을 갖는다. 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. 2.6 prototype 프로퍼티 함수 객체만이 소유하는 프로퍼티 일반 객체에는 prototype 프로퍼티가 없다. 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.","link":"/2020/03/javaScript/js.firstClassObject/"},{"title":"javaScript/js.expresstion&statement","text":"expresstion and statement값(value)? 값(value)는 표현식(expression)이 평가(evaluate)되어 생성된 결과 110 + 20 ; //30 10 + 20은 평가되어 숫자 값 30을 생성 1var sum = 10 + 20; 변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다. sum에 할당(assignment)되는 것은 10 + 20이 아니라, 10 +20이 평가된 결과인 숫자 값 30. 10 + 20은 할당 이전에 평가되어 값을 생성해야 한다. 리터럴(literal)? 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식(notaion) js 엔진은 코드가 실행되는 시점(runtime)에 literal을 평가하여 값을 생성한다. 표현식(expresstion)? 표현식(expresstion)은 값으로 평가(evaluation)될 수 있는 문(statement)이다. 표현식이 평가되면 값을 생성하거나 값을 참조한다. 표현식은 리터럴, 식별자(변수,함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이루어질 수 있다. (식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식) 문(statement)? 문(statement)는 프로그램을 구성하는 기본단위이자 최소 실행 단위이다. 여러 토큰(token)들로 구성된다. (문법적으로 더 이상 나눌 수 없는 코드의 기본요소ex) 키워드, 식별자, 연산자, 리터럴, 세미콜론; , 마침표. , 명령문이라고도 부름 (선언문, 할당문, 조건문, 반복문) 표현식인 문과 표현식이 아닌 문 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다. 표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식이 아닌 문1234var x;변수에 할당var foo = var x; 표현식인 문1234x = 100;변수에 할당var foo = x = 100;","link":"/2020/02/javaScript/js.expresstion&statement/"},{"title":"javaScript/js.function","text":"함수1. 함수란?input을 받아서 output을 내보내는 일련의 과정함수는 함수 정의(Function definition)를 통해 생성한다.JS의 함수는 다양한 방법으로 정의할 수 있다.함수의 정의만으로 함수가 실행되지 않는다. 인수 -&gt; 매개변수를 통해 함수에게 전달하면서 함수의 실행을 명시적으로 지시해야한다. 이를 함수호출(Function call/invoke)이라 한다. 12345// f(x, y) = x + yfunction add(x, y) { //함수 정의 return x + y;}add(2, 5); //7 //함수 호출 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 반환값을 반환한다. 2. 함수의 사용 이유 동일한 작업을 반복적으로 수행한다면, 미리 정의된 함수를 재사용하는 것이 효율적이다.함수는 얼마든지 호출할 수 있으므로 코드의 재사용의 측면에서 매우 유용하다. 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 코드의 가독성을 향상시킨다. (객체타입의 값이라 식별자를 붙일 수 있음) 3. 함수 리터럴JS의 함수는 객체 타입의 값함수 리터럴은 function 키워드, 함수 이름, 매개변수, 함수 몸체로 구성된다. 1234// 변수에 함수 리터럴을 할당var add = function add(x, y) { return x + y;}; 함수는 호출할 수 있지만, 일반 객체는 호출할 수 없다.함수 객체만의 고유한 프로퍼티를 갖는다. 함수이름 함수 이름은 식별자. 네이밍 규칙을 준수해야한다. 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다. 함수 이름은 생략 가능하다. 매개변수 목록 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 함수 호출문의 인수가 순서대로 할당된다. 매개변수 목록은 순서에 의미가 있다. 함수 몸체 내에서 변수와 동일하게 취급된다. 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야한다. 함수 몸체 함수 몸체는 함수 호출에 의해 실행된다. 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 4. 함수 정의함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것을 말한다. 123456789101112131415// 함수 선언문function add(x, y) { return x + y;}// 함수 표현식var add = function (x, y) { return x+y;};//function 생성자 함수var add = new Function('x', 'y', 'return x + y');//화살표 함수 (ES6에 추가)var add = (x, y) =&gt; x + y; 4.1 함수 선언문 함수 선언문은 리터럴과 형태가 동일하다. 함수 선언문은 함수 이름을 생략할 수 없다. 함수 선언문은 표현식이 아닌 문이다. (선언문이기 때문에 undefined를 출력한다.) 표현식이 아닌 문은 변수에 할당할 수 없지만, 함수 선언문은 변수에 할당하는 것 처럼 보인다. JS 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 함수는 함수 이름으로 호출하는게 아니라 함수 객체를 가리키는 식별자로 호출한다. 자바스크립트 엔진은 함수선언문을 함수 표현식으로 변환하여 함수 객체를 생성한다고 생각할 수 있다. 4.2 함수 표현식 자바스크립트의 함수는 일급 객체 (함수를 값처럼 자유롭게 사용할 수 있음) 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 함수 리터럴의 함수 이름은 생략할 수 있다. (생략하는 것이 일반적, 익명 함수) 함수 선언문과 함수 표현식의 차이. 함수 생성 시점과 호이스팅 4.3 함수 생성 시점과 함수 호이스팅함수 선언문과 함수 표현식은 함수 생성 시점이 다르다. 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 함수 객체를 할당 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화 함수 표현식은 변수 할당문의 값이 함수 리터럴인 문 함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다. 변수 할당문의 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다. 함수 표현식 이전에 함수를 참조하면 타입에러가 발생한다. 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다. 4.4 Function 생성자 함수 (빌트인 함수) (Constructor Function) 생성자 함수는 객체를 생성하는 함수. Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다. 4.5 화살표 함수 화살표 함수는 항상 익명 함수로 정의한다. 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. 5. 함수 호출 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다. 함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 호출하면 현재의 실행 흐름을 중단, 호출된 함수로 컨트롤을 넘긴다.인수 -&gt; 매개변수 할당 , 함수 몸체의 문들이 실행 5.1 매개변수와 인수함수 외부에서 함수 내부로 필요 값을 전달할 필요가 있는 경우 인수(외부) -&gt; 매개변수(내부) 인수는 값으로 평가될 수 있는 표현식이어야 하며, 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급한다.(함수가 호출되면 함수 몸체 내에 암묵적으로 매개변수가 생성되고, undefined로 초기화된 이후 인수가 순서대로 할당된다.) 호출될 때마다 이 단계를 거침 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.(스코프는 함수 내부이다.) 매개변수와 인수의 개수를 체크하지 않는다. 인수가 부족하면 할당되지 않은 매개변수의 값은 undefined 초과된 인수는 무시된다. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. 5.2 인수 확인 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.따라서 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요하다. 5.3 매개변수의 최대 개수 이상적인 매개변수 개수는 0개이며 적을 수록 좋다. 3개 이상을 넘지 않는 것을 권장한다. (그 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다.) 매개변수의 개수나 순서가 변경되면 함수의 호출 방법도 변경되므로 함수를 사용하는 코드 전체가 영향을 받는다. (유지보수성도 나빠진다.) 5.4 반환문 실행 결과를 함수 외부로 반환(return) 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 반환문 이후에 다른 문이 존재하면 그 문은 무시된다. return 키워드 뒤에 지정한 값을 반환한다. 명시적을 지정하지 않으면 undefined가 반환된다. 반환문을 생략할 수 있다. 함수는 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다. 6. 참조에 의한 전달과 외부 상태의 변경함수의 매개변수에 값을 전달하는 방식 Call by value, Call by reference동작 방식은 값에 의한 전달, 참조에 의한 전달 123456789101112131415//primitive은 원시값, obj는 객체를 전달받는다.function changeVal(primitive, obj) { primitive += 100; obj.name = 'Kim';}//외부 상태var num = 100;var person = { name: 'Jung'};console.log(num); // 100console.log(person); // {name: 'Jung'}//원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달changeVal(num, person); 원시 값은 원본이 훼손되지 않는다. 객체는 원본이 훼손된다. 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 원본은 훼손되지 않는다. side-effect가 없다 객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 원본이 훼손된다. side-effect 발생 객체를 불변 객체로 만들어 사용해서 외부상태가 변경되는 side-effect를 없앨 수 있다. 7. 다양한 함수의 형태7.1 즉시실행함수(IIFE) 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수 없다. (첫번째 메인 페이지에 사용) 익명 함수를 사용하는 것이 일반적이다.12345(function () { var a = 3; var b = 5; return a + b;}()); 즉시 실행 함수는 반드시 그룹 연산자()로 감싸 주어야 한다. 그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다. 7.2 재귀 함수(recursive function) 함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 팩토리얼은 재귀 호출로 간단히 구현할 수 있다. 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 함수 호출은 반드시 함수를 가리키는 식별자로 해야 한다. 재귀 함수는 for 문이나 while 문으로 구현 가능하다. 7.3 중첩 함수(nested function) 함수 내부에 정의된 함수를 중첩함수 또는 내부 함수(inner function)라 한다. 중첩 함수를 포함하는 함수를 외부 함수(outer function)라 한다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할을 한다. 7.4 콜백 함수(Callback function)고차함수(Higher-Order Function, HOF)의 인자로 넘겨지는 함수.콜백 함수는 고차함수 내에서 수행된다. (내용 추가하기) 7.5 순수 함수와 비순수 함수순수 함수 - 부수효과가 없는 함수(외부 상태를 변경시키는)비순수 함수 - 부수효과가 있는 함수함수형 프로그래밍은 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다.","link":"/2020/02/javaScript/js.function/"},{"title":"javaScript/js.functionInES6","text":"ES6 함수의 추가 기능 함수의 구분 ES6 이전의 함수는 동일한 함수라도 다양한 형태로 호출할 수 있다. ES6 이전의 함수는 callable이며 constructor 이다. callable - 호출할 수 있는 함수 객체 constructor - 인스턴스를 생성할 수 있는 함수 객체 non-constructor - 인스턴스를 생성할 수 없는 함수 객체12345678910111213var foo = function () { return 1;};// 일반적인 함수로서 호출foo (); // 1// 생성자 함수로서 호출new foo (); // foo {}// 메소드로서 호출var obj = { a: foo };obj.a(); // 1 일반적으로 메소드라고 부르는 객체에 바인딩된 함수도 callable이며 constructor이다. 객체에 바인딩된 함수도 일반 함수, 생성자 함수로서 호출할 수도 있다. 바인딩된 함수가 constructor면 prototype 프로퍼티에 바인딩된 프로토타입 객체를 생성한다는 것을 의미 12345678910111213var obj = { x: 10; f: function () { return this.x; }};//프로퍼티 f에 할당된 함수를 메소드로서 호출console.log(obj.f()); // 10//프로퍼티 f에 할당된 함수를 일반 함수로서 호출var bar = obj.f;console.log(bar()); // undifined//프로퍼티 f에 할당된 함수를 생성자 함수로서 호출console.log(new obj.f()); // f {} ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없음 호출 방식에 특별한 제약 없음 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성 ES6에서는 사용 목적에 따라 함수를 3가지 종류로 명확히 구분함 ES함수의 구분 cosntructor prototype super arguments 일반 함수 O O x O 메소드 X X O O 화살표 함수 X X X X 2. 메소드 ES6 사양에서 메소드는 메소드 축약 표현으로 정의된 함수 만을 의미한다. 인스턴스를 생성할 수 없는 non-constructor, (생성자 함수로서 호출 불가) prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다. 12345678910111213141516const obj = { x: 1, foo () { // 메소드 return this.x; }, bar: function () { return this.x // 일반함수 바인딩 }};console.log(obj()); // 1console.log(bar()); // 1new obj.foo(); // TypeError: obj.foo is not a constructornew obj.bar(); // bar {} 일반함수여서 호출가능Object.prototype.hasOwnProperty.call(obj.foo, 'prototype'); // false 표준 빌트인 객체의 메소드는 모두 non-constructor ES6 메소드는 메소드가 바인딩된 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.super 참조는 [[HomeObject]]를 사용하여 수퍼 클래스의 메소드를 참조하므로 내부슬롯을 갖는 ES6 메소드만이 super 키워드를 사용할 수 있다. ES6 메소드가 아니면 super 키워드를 사용할 수 없다. (내부슬롯 안가지고있음)일반 함수로 super 키워드를 사용했을 시 SytaxError super 기능 추가, constructor 제거. 메소드 정의할 때, 프로퍼티 값으로 익명 함수 표현식을 할당하는 ES6 이전 방식은 더이상 사용 하지 말아야 함. 3. 화살표 함수3.1 화살표 함수 정의(1) 매개변수 선언 매개 변수가 여러 개인 경우, 소괄호 안에 매개 변수를 선언한다. 매개 변수가 한 개인 경우, 소괄호 생략할 수 있다. 매개 변수가 없는 경우, 소괄호를 생략할 수 없다. (2) 함수 몸체 정의 함수 몸체가 한 줄의 문으로 구성된다면 함수 몸체를 감싸는 중괄호 생략 가능이때 문은 암묵적으로 반환된다. 여러 줄의 문으로 구성된다면 중괄호 생략 불가능, 반환값이 있다면 명시적으로 반환해야한다. 12345678910111213141516171819202122x =&gt; x * x;x =&gt; { return x + x; } // 화살표 함수와 일반함수 비교const now = () =&gt; Date.now();var now () { return Date.now();}//const x = value =&gt; value;var x = function(value) { return value;};//const sum = (a, b) =&gt; a + b;var sum = function(a, b) { return a + b;} 객체 리터럴을 반환하는 경우, 객체 리터럴을 소괄호()로 감싸 주어야 한다. 12345678() =&gt; { return { a: 1 }; }() =&gt; ({ a: 1}) //같은 표현const create = (id, content) =&gt; ({ id, content });var create = function (id, content) { return { id, content };}; 화살표 함수도 즉시 실행 함수(IIFE)로 사용 가능 12345const person = (name =&gt; ({ sayHi() { return `My name is ${name}`;}}))('jung');console.log(person.sayHi()); 화살표 함수도 일급 객체.. 따라서 고차함수(HOF)에 인수로 전달할 수 있다. (Array.prototype.map/filter/reduce) 123456// ES6 [1, 2, 3].map( v =&gt; v * 2); // [2, 4, 6]// ES5[1, 2, 3].map(function (v) { return v * 2;}); 3.2 화살표 함수와 일반 함수의 차이(1) 화살표 함수는 non-constructor (인스턴스 생성X) 생성자 함수로 호출할 수 없다. (TypeError) prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다. (2) 중복된 매개 변수 이름을 선언할 수 없다. 일반 함수는 중복된 매개 변수를 선언해도 에러가 발생하지 않는다.(SytaxError) (3) 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다. 화살표 함수 내에서 참조하면 스코프 체인을 통해 상위 컨텍스트의 것을 참조한다. 3.3 this 중첩 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해. 화살표 함수는 함수 자체의 this 바인딩이 없다. 화살표 함수 내부에서 this를 참조하면 상위 컨텍스트의 this를 그대로 참조한다. 이를 Lexical this라 한다. 화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을의미.. 화살표 함수가 화살표 함수의 중첩 함수인 경우, 부모 화살표 함수가 참조하는 상위 컨텍스트의 this를 참조한다. 화살표 함수가 전역 함수라면 this는 전역 객체를 가리킴 123456789101112131415const foo = () =&gt; console.log(this);foo(); //window(function () { const foo = () =&gt; console.log(this); foo();}).call({ a: 1}); // { a: 1}//foo의 상위 컨텍스트는 즉시 실행함수. this는 즉시 실행함수를 가리킴const counter = { num: 1; increase: () =&gt; ++this.num};console.log(counter.increase()); //NaN// 상위 컨텍스트는 전역이므로 this는 전역 객체를 가리킴 화살표 함수 내부의 this는 Function.prototype.call/apply/bind 메소드를 사용하여 변경할 수 없다. 화살표 함수의 this는 일단 결정된 이후 변경할 수 없고 언제나 유지된다. 메소드를 화살표 함수로 정의하는 것은 자제해야 한다. 1234567891011121314151617const person = { name: 'jung' sayHi: () =&gt; console.log(`hi ${this.name}`)};person.sayHi(); // hi//전역 객체 window에 빌트인 프로퍼티 name이 존재//함수 내부의 this는 전역 객체를 가리키므로 브라우저에서 실행하면 빈문자열을 갖는// window.name이 출력된다.//// ES6 메소드 정의를 사용하기const person = { name: 'jung', sayHi() { console.log(`hi ${this.name}`); }};person.sayHi() //hi jung 프로토타입 객체에 화살표 함수를 할당하는 경우도 동일한 문제가 발생한다.(위 예제와) 프로토타입 객체에는 ES6 메소드 정의를 사용할 수 없으므로 일반 함수를 할당한다. 클래스 필드 정의 제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도있다. 클래스 필드에 할당한 화살표 함수는 프로토타입 메소드가 아니라 인스턴스의 메소드가 된다.ES6 메소드 정의를 사용하는 것이 좋다. 1234567class Person { name = 'jung'; sayHi() { console.log(`hi ${this.name}`); }}const person = new Person();person.sayHi(); //hi jung 3.4 super 화살표 함수는 함수 자체에 super 바인딩이 없다. 화살표 함수 내부에서 super를 참조하면 상위 컨텍스트의 super를 참조한다. super 내부슬롯 [[HomeObject]]를 갖는 ES6 메소드만이 사용할 수 있는 키워드 3.5 arguments 화살표 함수는 함수 자체의 arguments 바인딩이 없다. 함수 내부에서 arguments를 참조하면 상위 컨텍스트의 argumnets를 참조한다. 상위 컨텍스트의 arguments 객체를 참조할 수는 있지만 화살표 함수 자신에게 전달된 인수 목록을 확인할 수 없으므로 도움이 되지 않음1234567891011(function () { const foo = () =&gt; console.log(arguments); //[Arguments] { '0': 1, '1' : 2} foo(3, 4);}(1 ,2));// 화살표 함수 foo의 arguments는 즉시 실행 함수의 arguments를 가리킨다. // 중첩 함수 foo의 상위 컨텍스트가 즉시 실행함수..//const bar = () =&gt; console.log(arguments);bar(1 ,2); // ReferenceError// 전역 함수 bar의 상위 컨텍스트는 전역, 전역에는 arguments 객체가 없다. //(함수 내에서만 유효) 4 Rest 파라미터4.1 기본 문법Rest 파라미터(나머지 매개변수)는 매개변수 이름 앞에 세개의 점을 붙여서 정의한 매개변수를 의미한다. 함수에 전달된 인수들의 목록을 배열로 전달받는다. 12345678910111213function foo (...rest) { console.log(rest); [1, 2, 3, 4, 5] console.log(Array.isArray(rest)); // true}foo(1, 2, 3, 4, 5);// 함수에 전달된 인수들은 순차적으로 파라미터와 Rest 파라미터에 할당된다.function bar (param1, param2, ...rest) { console.log(param1); // 1 console.log(param2); // 2 console.log(rest); // [ 3, 4, 5 ]}bar (1, 2, 3, 4, 5); Rest 파라미터는 반드시 마지막 파라미터여야한다. (SyntaxError) Rest 파라미터는 단 하나만 선언할 수 있다. 함수 객체의 length 프로퍼티에 영향을 주지 않는다. 4.2 Rest 파라미터와 arguments 객체 ES5에서는 가변 인자 함수의 경우, arguments 객체를 통해 인수를 확인한다.arguments 객체는 유사 배열 객체이며 함수내부에서 지역 변수처럼 사용할 수 있다. 가변 인자 함수는 파라미터를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받는다. arguments 객체는 유사 배열 객체이므로 배열 메소드를 사용하려면 Function.prototype.call 메소드를 통해 this를 변경하여 배열 메소드를 호출해야함 ES6에서는 rest 파라미터를 사용하여 가변인자의 목록을 배열로 직접 전달받을 수 있다. 유사 배열인 arguments 객체를 배열로 변환하는 번거로움을 피할 수 있다. 1234567891011121314function sum() { var array = Array.prototype.slice.call(arguments); //유사 배열 객체인 argments 객체를 배열로 변환한다. return array.reduce(function (pre, cur) { return pre + cur; });}console.log(sum(1, 2, 3, 4, 5)); //15 ?//ES6function sum(...args) { return args.reduce((pre, cur) =&gt; pre + cur);}console.log(sum(1, 2, 3, 4, 5)); // 15 화살표 함수는 함수 자체의 arguments 객체를 갖지 않는다. 화살표 함수로 가변인자 함수를 구현해야 할 때는 반드시 rest 파라미터를 사용해야 한다. 5. 매개변수 기본값 매개변수에 적절한 인수가 전달되었는지 함수 내부에서 확인할 필요가 있다.방어 코드가 필요. ES6에서는 매개변수 기본값을 사용하여 함수 내에서 수행하던 인수 체크, 초키화를 간소화할 수 있다. 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우와 undifined를 전달한 경우에만 유효하다. Rest 파라미터에는 기본값을 지정할 수 없다. (SyntaxError) 매개변수의 기본값은 함수 객체의 length 프로퍼티와 argument 객체에 영향을 주지않는다.1234567891011121314151617181920212223242526272829function sum (x, y) { x = x || 0; y = y || 0; return x + y;}console.log(sum(1, 2)); //3console.log(sum(1)); //1//function sum (x = 0, y = 0) { return x + y;}//function logName (name = 'jung') { console.log(name);}logName(); //junglogName(undifined); //junglogName(null); //null//function sum(x, y = 0) { console.log(arguments);}console.log(sum.length); //1? 2 아닌가?sum(1); // Arguments { '0': 1 }sum(1, 2); // Arguments { '0' : 1, '1' : 2}","link":"/2020/03/javaScript/js.functionInES6/"},{"title":"javaScript/js.mouseEvent","text":"mouseover 와 mouseenter 이벤트 차이버블링의 차이 mouseover는 직접 이벤트를 걸지않은 자식요소에 마우스 포인터가 와도 발생mouseout과 한 쌍을 이룬다.( 버블링이 발생한다 ) mouseenter는 오로지 자신에게 마우스 포인터가 와야만 발생한다.mouseleave와 한 쌍을 이룬다.( 버블링이 발생하지 않는다 )","link":"/2020/05/javaScript/js.mouseEvent/"},{"title":"javaScript/js.let const and var","text":"let, const와 블록 레벨 스코프 (feat. var)1. var로 선안한 변수의 문제점1.1 변수 중복 선언 허용 같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 자바 스크립트 엔진에 의해 var 키워드가 없는 것 처럼 동작한다. 먼저 선언된 변수값이 변경되는 부작용 발생 문법적으로 허용, 하지만 사용하지 않는 것이 좋다. 1.2 함수 레벨 스코프 오직 함수 코드블록만을 지역 스코프로 인정한다. 함수 외부에서 var 키워드 선언 -&gt; 전역 변수(코드 블록 내에 있더라도 for문 등등..) 1.3 변수 호이스팅 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 가독성을 떨어뜨리고 오류를 발생시킬 가능성이 있다. 2. let 키워드 var 를 보안하기 위해 ES6에서 let, const 도입 2.1 변수 중복 선언 금지 let 키워드로 동일한 변수를 중복 선언하면 SyntaxError가 발생한다. 2.2 블록 레벨 스코프let 키워드로 선언한 변수는 모든 코드블록 (함수, if, for, while, try/catch문 등)을 지역 스코프로 인정하는 블록레벨 스코프를 따른다. 블록레벨스코프 = 지역 스코프 = 지역변수 12345678910let i = 10; // &lt;- 전역 스코프function foo() { // &lt;= 함수 레벨 스코프 let i = 100; for (let i = 1; i &lt; 3; i++) { console.log(i); // 1, 2 &lt;= 블록 레벨 스코프 } console.log(i); // 100}foo ();console.log(i); //10 2.3 변수 호이스팅let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 12console.log(x); //ReferenceError: foo is not definedlet x; let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행한다 (!== var) 런타임 이전에 암묵적으로 선언 단계 먼저 실행(자바스크립트 엔진에 의해) 초기화 단계는 선언문에 도달했을 때 실행된다. 초기화 단계가 실행되기 이전에 변수에 접급하려고 하면 참조에러가 발생된다. 스코프의 시작지점부터 초기화 시작 지점까지 변수를 참조할 수 없다. (TDZ) let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것 처럼 동작한다. 2.4 전역객체와 let let, const 키워드로 선언한 전역 변수는 전역 객체(window)의 프로퍼티가 아니다. let 전역 변수는 보이지 않는 개념적인블록 내에 존재하게 된다. 3.1 const3.1 선언과 초기화 const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면 SyntaxError 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 블록 레벨 스코프를 갖는다. 3.2 재할당 금지const로 선언한 변수 재할당 금지 (let, var 가능) 3.3 상수 상수. 값을 저장하기 위하 메모리 공간이 필요함으로 변수라고 할 수 있다. (재할당금지) 상태 유지와 가독성, 유지보수의 편의를 위해 사용해야한다. 3.4 const와 객체 const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다. 재할당을 금지할 뿐 불변을 의미하지 않는다. 객체의 내용이 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.123456const person = { age: '32'};person.name = '20';console.log(person); // {age: '20'}","link":"/2020/02/javaScript/js.let%20const%20and%20var/"},{"title":"javaScript/js.global variable","text":"전역 변수의 문제점전역 변수의 무분별한 사용은 위험하다. 반드시 사용해야 할 이유를 찾지 못한다면 지역 변수를 사용해야한다. 1. 변수의 생명 주기변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.생명주기(Life cycle)이 있다. 1.1 지역 변수의 생명 주기지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 12345function foo() { var x = 'local'; console.log(x); return x;} 지역 변수 x는 변수가 호출되기 이전까지는 생성되지 않는다. 함수 내부에서 선언한 변수는 함수가 호출된 직후, 함수 몸체의 다른 코드가 실행되기 전에 자바스크립트에 의해 실행되고 undefined로 초기화된다. 그 후, 함수 몸체의 문들이 순차적으로 실행되고 변수 할당문이 실행되면 변수에 값이 할당된다. 함수가 종료하면 지역 변수도 소멸되어 생명 주기가 종료된다. 지역 변수 생명주기 == 함수 생명 주기 1.2 전역 변수의 생명 주기 전역 코드는 명시적 호출없이 실행된다. 코드가 로드되자마자 곧바로 해석하고 실행 전역 코드에는 함수처럼 return문을 사용할 수 없으므로 마지막 문이 실행 된 후, 더이상 실행할 문이 없을 때 종료한다. return 문의 위치 return문은 함수 내부에서만 사용 가능하다. 전역에서 사용하면 SyntaxError가 발생한다. Node.js 환경에서는 파일의 가장 바깥 영역에 return문을 사용해도 에러가 발생하지 않는다. 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갖기 때문이다. var 키워드로 선언된 전역 변수는 전역 객체의 프로퍼티가 된다.전역 변수의 생명주기 == 전역 객체의 생명 주기 전역 객체(Global Object) 코드가 실행되기 이전 단계에서 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 클라이언트 사이드 환경(브라우저) window 서버 사이드 환경(Node.js) global객체 전역 객체에는 표준 빌트인 객체, 호스트 객체, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 표준 빌트인 객체(Object, String, Number, Function, Array 등) 호스트 객체(클라이언트 web API, Node.js의 호스트 API) 2. 전역 변수의 문제점암묵적 결합 전역 변수를 선언한 의도는 어디에서든지 전역 변수를 사용하겠다는 것이다. 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것이다. 변수의 유효범위가 클수록 코드의 가독성은 나빠지고, 의도치 않게 상태가 변경될 수 있는 위험성 또한 높아진다. 긴 생명 주기전역 변수는 생명 주기가 길다. 메모리 리소스도 오랜기간 소비한다. 전역 변수의 상태를 변경할 수 있는 시간도 길고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다. var 키워드는 변수의 중복 선언을 허용하므로, 변수 이름이 중복될 가능성이 있다. (의도치 않는 재할당) 스코프 체인 상에서 종점에 존재변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다. 전역 변수의 검색속도가 가장 느리다. 네임 스페이스 오염파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.다른 파일 내에서 동일한 이름으로 생성된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. 3. 전역 변수 사용 억제 방법전역 변수를 반드시 사용할 이유가 없다면 지역 변수를 사용해야한다. 변수의 스코프는 좁을수록, 빨리 소멸될 수록 좋다. 3.1 즉시 실행 함수함수의 정의와 동시에 단 한번 만 호출된다.함수 내의 지역 변수는 바로 소멸된다.이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다. 3.2 네임 스페이스 객체 전역에 네임스페이스 역할을 담당할 객체를 생성하고, 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다. 12345var MYAPP = {}; // 네임 스페이스 객체 (전역)MYAPP.name = 'Lee';console.log(MYAPP.name); //Lee 네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다. 12345678var MYAPP = {}; // 네임 스페이스 객체 (전역)MYAPP.person = { name: 'Lee', address: 'Seoul' //네임 스페이스 계층};console.log(MYAPP.person.name); //Lee 네임 스페이스를 분리하여 식별자 충돌을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역 변수에 해당되므로 그다지 유용해 보이지는 않는다. 3.3 모듈 패턴모듈 패턴은 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 클로저를 기반으로 동작한다.모듈 패턴의 특징 전역 변수의 억제 캡슐화 구현 (캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉이라고도 한다.) 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능은 한정적.캡슐화를 구현하기 위해 사용한다. 3.4 ES6 모듈전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다.script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 1&lt;script type=\"module\" src=\"lib.mjs\"&gt;&lt;/script&gt; 모던 브라우저에만 동작, IE를 포함한 구형 브라우저에는 동작하지 않는다. 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에, 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다. 새로운 개념.. 네임 스페이스, 모듈패턴, 트랜스 파일링, 번들링","link":"/2020/02/javaScript/js.global%20variable/"},{"title":"javaScript/js.promise","text":"1. 프로미스?비동기 처리를 위해 콜백 함수를 사용한다.하지만 콜백 패턴은 가독성이 나쁘고 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며 여러 개의 비동기 처리 로직을 한꺼번에 처리하는 것도 한계가 있다. 이를 보완하기위해 ES6에서 프로미스를 도입. 비동기 처리 시점을 명확하게 표현한다.후속 처리 메소드를 체이닝(chainning)하여 여러 개의 프로미스를 연결하여 사용할 수 있다. 2. 콜백 패턴의 단점2.1 콜백 헬 (Callback Hell)콜벡 헬이 발생하는 이유비동기 처리 모델은 실행 완료를 기다리지 않고 즉시 다음 태스크를 실행한다.따라서 비동기 함수 내에서 처리 결과를 반환하면 기대한 대로 동작하지 않는다. 비동기식 처리 모델(병렬적 태스크 수행) 태스크가 종료되지 않은 상태여도 대기하지 않고 즉시 다음 태스크 실행(Non-Blocking) DOM 이벤트, Timer 함수, Ajax 요청 비동기 처리를 위해 콜백 패턴을 사용하면 처리 순서를 보장하기 위해 여러 개의 콜백 함수가 네스팅(nesting)되어 복잡도가 높아지는 콜백 헬이 발생된다. (가독성 안좋음) 2.2 에러 처리의 한계3. 프로미스의 생성Promise 생성자 함수를 통해 인스턴스화한다. 1234567const promise = new Promise((resolve, reject) =&gt; { if (//비동기 작업 수행 성공) { resolve('result'); // fulfilled 상태 } else { // 비동기 작업 수행 실패 reject('failure reason'); // rejected 상태 }}); 4. 프로미스의 후속 처리 메소드 Promise로 구현된 비동기 함수는 Promise 객체를 반환하여야 한다. Promise 객체의 후속 처리 메소드(then, catch)를 통해 비동기 처리 결과 또는 에러 메시지를 전달받아 처리한다. Promise 객체는 상태를 갖는다. 이 상태에 따라 후속 처리 메소드를 체이닝 방식으로 호출한다. then 두 개의 콜백 함수를 인자로 전달 받는다. 첫번째 콜백함수 - 성공시 호출 (fulfilled, resolve 함수가 호출된 상태) 두번째 콜백 함수 - 실패시 호출 (rejected, reject 함수가 호출된 상태) then 메소드는 Promise를 반환한다. catch 예외가 발생하면 호출 (비동기 처리에서 발생한 에러, then 메소드에서 발생한 에러) Promise를 반환한다. 5. 프로미스의 에러 처리6. 프로미스 체이닝7. 프로미스의 정적 메소드7.1 Promise.resolve / Promise.reject존재하는 값을 Promise로 래핑하기 위해 사용 7.2 Promise.all각각의 프로미스가 resolve한 처리 결과를 배열에 담아 resolve 하는새로운 프로미스 반환처리순서가 보장 7.3 Promise.race가장 먼저 처리된 프로미스가 resolve한 처리 결과를 resolve하는 새로운 프로미스를 반환병렬처리 x","link":"/2020/04/javaScript/js.promise/"},{"title":"javaScript/js.object literal","text":"객체란? 자바스크립트는 객체기반의 프로그래밍 언어, 원시 값을 제외한 나머지 모든 값들이 객체이다. 원시 값이랑 반대로 객체는 변경 가능한 값이다. 객체는 키(key) 값(value)로 구성된 프로퍼티(Property)들의 집합 12345var person = { name : 'Lee' // 프로퍼티 age : 20 // 프로퍼티 //name, age 프로퍼티 키 / 'Lee' 20 프로퍼티 값}; 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 메소드(Method)라 부른다. 프로퍼티: 객체의 상태를 나타내는 값 메소드: 프로퍼티를 참조하고 조작할 수 있는 동작 123456var counter = { num: 0, //프로퍼티 increase: function(){ //메소드 this.num++; }} 객체 리터럴에 의한 객체 생성자바스크립트는 프로토타입 기반 객체지향 언어로서 클래스 기반 객체지향 언어와는 다른 다양한 객체 생성 방법이 존재한다.(객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create메소드, 클래스(ES6) ) 객체리터럴은 중괄호 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 엔진은 객체리터럴을 해석하여 객체를 생성한다. 중괄호 내에 프로퍼티를 정의하지 않으면 빈 객체가 생성된다. 객체 리터럴은 값으로 평가되는 표현식이다. 객체 리터럴에 프로퍼티를 포함시켜 객체의 생성과 동시에 프로퍼티를 만들 수도 있고, 객체를 생성한 이후에 프로퍼티를 동적으로 추가할 수 있다. 프로퍼티키(key) + 값(value) = 프로퍼티프로퍼티의 집합 = 객체 프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든 값 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 symbol 값프로퍼티 갑셍 접근할 수 있는 이름으로 식별자 역할을 한다. 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용하여야 한다. 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 사용하면 암묵적 타입변환을 통해 문자열이 된다. 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 덮어쓴다. 에러는 발생하지 않는다. 메소드자바스크립트에서 사용할 수 있는 모든 값을 프로퍼티 값으로 사용할 수 있다.프로퍼티 값이 함수일 경우, 일반함수와 구분하기 위해 메소드라 부른다. 프로퍼티 접근 프로퍼티 값에 접근하려면 마침표 표기법(Dot notation) 또는 대괄호 표기법(Bracket notation)을 사용한다. 대괄호 내에 들어가는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이여야 한다. 단 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 생략가능 12345678var person = { name : 'Jung'};//마침표 표기법에 의한 프로퍼티 접근console.log(person.name); //Jung//대괄호 표기법에 의한 프로퍼티 접근 , 대괄호 내 프로퍼티 키는 반드시 따옴표로 감싼 문자열이여야 함console.log(person['name']) //Jung 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환 프로퍼티 동적 생성존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다. 프로퍼티 삭제delete 연산자는 객체의 프로퍼티를 삭제한다.delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이여야 한다. 객체 리터럴의 확장 기능(ES6)프로퍼티 축약 표현프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.변수 이름과 프로퍼티 키가 동일한 이름일 떄, 생략가능 12345let x = 1, y = 2;const obj = {x, y};console.log(obj); // {x:1 , y:2} 프로퍼티 키 동적 생성ES6에서는 객체 리터럴 내부에도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다. 메소드 축약 표현ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현 사용 가능","link":"/2020/02/javaScript/js.object%20literal/"},{"title":"javaScript/js.property","text":"프로퍼티 어트리뷰트1. 내부 슬롯과 내부 메소드 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMA 사양에서 사용하는 의사 프로퍼티와 의사 메소드 이다. [[]] 외부로 공개된 객체의 프로퍼티는 아니다. 간접적으로만 접근할 수 있다. 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의 프로퍼티 상태?프로퍼티의 값(value), 값의 갱신 가능여부(writable), 열거가능여부(enumberable), 재정의 가능여부(configurable) 프로퍼티 어트리뷰트 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property) Object.getOwnPropertyDescriptor 메소드를 이용해 간접적으로 확인할 수 있다. (직접적 불가) 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor)객체를 반환 만약 존재하지 않는 프로퍼티, 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undifined가 반환 ES8에 도입된 Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환 3. 데이터 프로퍼티와 접근자 프로퍼티 데이터 프로퍼티(date property) 키와 값으로 구성된 일반적인 프로퍼티 잡근자 프로퍼티(Accessor property) 자체적으로는 값을 갖지않고, 다른 데이터 프로퍼티 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티 3.1 데이터 프로퍼티데이터 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다. 프로퍼티 어트리뷰트 프로퍼티 디스크립터 객체의 프로퍼티 설명 [[Value]] vlaue - 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값 -프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다. 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의[[Value]]에 값을 저장한다. [[Writable]] writable - 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. - false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는는 읽기 전용 프로퍼티가 된다. [[Enumberable]] enumberable - 프로퍼티의 열거 가능여부를 나타내며 불리언 값을 갖는다.- false인 경우, 해당 프로퍼티는 for…in문이나 Object.keys 메소드 등으로 열거할 수 없다. [[Configurable]] configurable - 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다. - false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단 [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. 123456const person = { name: 'Lee'};console.log(Object.getOwnpropertyDescriptor(person.'name'));// { value: \"Lee\", wrtable: true, enumberale: true, configurable: true} 3.2 접근자 프로퍼티 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다. getter, setter 함수라고도 부른다. 두 함수 모두 정의할 수 있고, 하나만 정의할 수도 있다. 프로퍼티 어트리뷰트 프로퍼티 디스크립터 객체의 프로퍼티 설명 [[Get]] get - 데이터 프로퍼티의 값을 저장할 때 호출프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, getter 함수가 호출, 그결과가 프로퍼티 값으로 반환된다. [[Set]] set 데이터 프로퍼티의 값을 저장할 때 호출프로퍼티 어트리뷰트[[Set]]의 값, setter함수가 호출되고 그결과가 프로퍼티 값으로 저장된다. [[Enumberable]] enumberable 데이터 프로퍼티의 [[Enumerable]]와 같다. [[Configurable]] configurable 데이터 프로퍼티의 [[Configurable]]와 같다. 프로퍼티 키가 유효한지 확인한다. 문자열 또는 심볼이여야 한다. 프로토타입 체인에서 프로퍼티를 검색한다. 검색된 프로퍼티가 데이터 프로퍼티인지, 접근자 프로퍼티인지 확인한다. 프로퍼티 어트리뷰트 [[Get]]. getter 함수를 호출하여 그 결과를 반환한다. 4. 프로퍼티 정의 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트릴뷰트를 재정의 하는 것 객체의 프로퍼티가 어떻게 동작해야 하는지 명확히 정의할 수 있다. Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다. Object.defineProperty 메소드로 프로퍼티 정의할 때, 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다. 프로퍼티 디스크립터 객체의 프로퍼티 대응하는 프로퍼티 어트리뷰트 디스크립터 객체의 프로퍼티 누락시 기본값 value [[Value]] undifined get [[Get]] undifined set [[Set]] undifined writable [[Writable]] false enumberable [[Enumberable]] false configurable [[Configurable]] false 5. 객체 변경 방지 객체는 변경 가능한 값. 재할당 없이 직접 변경 가능 Object.defineProperty or Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수 도있다. 자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공 5.1 객체 확장 금지 Object.preventExtensions 메소드는 객체의 확장을 금지 확장이 금지된 객체는 추가가 금지된다. 동적추가와, 메소드로 추가 둗가지 모두 금지 확장금지 객체 여부는 Object.isExtensible 메소드로 확인 가능하다 5.2 객체 밀봉 Object.seal 메소드는 객체를 밀봉 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의를 금지한다. 밀봉된 객체는 읽기와 쓰기만 가능 밀봉 객체 여부는 Object.isSealed 메소드로 확인가능 5.3 객체 동결 Object.freeze 메소드는 객체를 동결 프로퍼티 추가 삭제 금지, 재정의 금지, 갱신 금지 동결된 객체는 읽기만 가능 Object.Frozen 메소드로 확인가능 5.4 불변 객체 위 메소드들은 얕은 변경방지(Shallow only) =&gt; 직속 프로퍼티에만 변경이 방지되고 중첩 객체 까지는 영향을 주지 못한다. 객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변객체를 구현하려면, 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.","link":"/2020/02/javaScript/js.property/"},{"title":"javaScript/js.scope","text":"스코프스코프는 변수, 함수와 관련있다. 스코프는 식별자가 유효한 범위를 말한다. 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고, 함수 몸체 외부에서는 참조할 수 없다.매개변수의 스포크가 함수 몸체 내부로 한정되기 때문이다. 변수는 코드의 가장 바깥영역(window)뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언할 수 있다. 코드 블록이나 함수는 중첩될 수 있다.변수는 자신이 선언된 위치에 의해 자신이 유효한 범위(다른 코드가 변수 자신을 참조할 수 있는 범위)가 결정된다.이를 스코프라 한다. 프로그래밍 언어에서 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있도록 한다. 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다. 스코프의 종류코드는 전역(global)과 지역(local)으로 구분할 수 있다. 이때 변수는 자신이 선언된 위치(전역 or 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다. 전역이란 코드의 가장 바깥쪽 영역(global)을 말한다.전역은 전역 스코프를 만들고, 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다. 전역 변수는 어디서든 참조할 수 있다. 지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만들고, 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다.지역 변수는 자신이 선언된 지역과 하위 지역(중첩함수)에서만 참조할 수 있다. 스코프 체인함수의 중첩 - 함수 몸체 내부에서 함수가 정의된 것중첩 함수(nested function) - 함수 몸체 내부에서 정의한 함수외부 함수(outer function) - 중첩 함수를 포함하는 함수 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부함수의 지역 스코프와 계층적 구조를 갖는다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다.지역 -&gt; 전역 렉시컬 환경(Lexical Environment)스코프 체인은 실행 컨택스트(Execution Contxt)의 렉시컬 환경(Lexical Environment)을 단방향으로 연결한 것이다.전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다. 스코프 체인에 의한 변수 검색상위 스코프에서 유효한 변수는 하위스코프에서 참조할 수 있지만,하위 스코프에서 유효한 변수를 상위스코프에서 참조할 수 없다. 함수 레벨 스코프코드블록 아닌 함수에 의해서만 지역 스코프가 생성된다. 블록 레벨 스코프(Block level scope)모든 코드블록이 지역 스코프를 만든다.let, const (ES6) 함수 레벨 스코프(Function level scope)var 키워드로 선언된 변수는 오로지 함수이 코드 블록 만을 지역 스코프로 인정한다. 렉시컬 스코프12345678910111213var x = 1;function A() { var x = 10; B();}function B() { console.log(x);}A(); //?B(); //? 함수 B의 상위 스코프가 무엇인지에 따라 결정된다. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. 함수 B의 상위 스코프는 함수 A와 전역 동적 스코프(Dynamic scope) 함수 정의 시점에는 함수가 어디서 호출될지 알 수 없다. 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. 함수 B의 상위 스코프는 전역 렉시컬 스코프(Lexical scope), 정적스코프(Static scope) 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.","link":"/2020/02/javaScript/js.scope/"},{"title":"javaScript/js.spreadSyntax","text":"스프레드 문법 (Spread syntax, 전개문법)ES6에서 새롭게 도입된 문법 …은 하나로 뭉쳐있는 여러 값들의 집합을 펼쳐서 개별적인 값들의 목록을 만든다. Array, String, Map, Set, Dom 컬렉션(NodeList, HTMLCollection), Arguments와 같이 for…in문으로 순회할 수 있는 이터러블에 한정된다. 12345console.log(...[1, 2, 3]) // 1 2 3console.log(...'young'); // y o u n gconsole.log(... { a: 1, b: 2}); // TypeError: Found non-callable @@iterator 스프레드 문법의 결과는 값이 아니라 값들의 목록이다. 값이 아니라 변수에 할당할 수 없다. 연산하여 값을 생성하는 연산자도 아니다. 결과물은 단도그로 사용할 수 없다. 쉼표로 구분한 값의 목록을 사용하는 문에서 사용된다. 함수 호출문의 인수 목록 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 (Stage 4) 1. 함수 호출문의 인수 목록에서 사용하는 경우 Math.max 메소드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없다 (NaN) 이를 위해 Function.prototype.apply 사용 위 메소드보다 스프레드 문법이 간결하고 가독성이 좋다.123const arr = [1, 2, 3];const maxValue = Math.max(...arr);console.log(maxValue); //3 Rest 파라미터와 혼동 주의 Rest 파라미터 - 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개 변수 이름 앞에 … 스프레드 문법 - 배열같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것 2. 배열 리터럴 내부에서 사용하는 경우 ES5에서 사용하던 방식과 비교 2.1 concat기존의 배열 요소들을 새로운 배열의 일부로 만들고 싶은 경우 123456var arr = [1, 2].concat([3, 4]);console.log(arr); //[1, 2, 3, 4]//// 스프레드 문법const arr = [...[1, 2], 3, 4];console.log(arr); // [1, 2, 3, 4] 2.2 push기존의 배열에 다른 배열의 요소들을 push 12345678910111213var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4]//// 스프레드 문법const arr1 = [1, 2];const arr2 = [3, 4];arr1.push(...arr2);// arr1.push(3, 4);console.log(arr1); //[1, 2, 3, 4] 2.3 splice기존의 배열에 다른 배열의 요소들을 삽입 1234567891011121314151617var arr1 = [1, 4];var arr2 = [2, 3];Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));// apply 메소드의 두번째 인수는 배열. 이것을 인수 목록으로 splice 메소드에 전달된다.// [1, 0].concat(arr2) = &gt; [1, 0, 2, 3]// arr1.splice(1, 0, 2, 3) = &gt; arr1[1]부터 0개 요소 제거// (arr1[1])에 (2, 3) 삽입console.log(arr1); //[1, 2, 3, 4]//// 스프레드 문법const arr1 = [1, 4];const arr2 = [2, 3];arr1.splice(1, 0, ...arr2);console.log(arr1); // [1, 2, 3, 4] 2.4 배열 복사기존의 배열을 복사하기 위해서는 slice 메소드를 사용배열의 각 요소를 얕은 복사하여 새로운 복사본 생성 123456789101112var = origin = [1, 2];var copy = origin.slice();console.log(copy); // [1, 2]console.log(copy === origin); // false//// 스프레드 문법const origin = [1, 2];const copy = [...origin];console.log(copy); // [1, 2]console.log(copy === origin); // false 2.5 유사 배열 객체를 배열로 변환유사 배열 객체를 배열로 변환하려면 slice메소드를 apply 함수로 호출 123456789101112131415161718function sum () { var args = Array.pototype.slice.apply(arguments); return args.reduce(function (pre, cur) { return pre + cur; }, 0); }console.log(sum(1, 2, 3)); // 6//// 스프레드 문법 function sum () { const args = [...arguments]; return args.reduce((pre, cur) =&gt; pre + cur, 0);}console.log(sum(1, 2, 3)); // 6 3. 객체 리터럴 내부에서 사용하는 경우TC39 프로세스의 stage 4 단계에 제안되어 있다.스프레드 문법은 이터러블이여야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다. 1234567891011121314151617181920212223242526272829303132333435363738394041// 객체 복사 (얕은)const obj = { x: 1, y: 2};const copy = { ...obj };console.log(copy); // { x: 1, y: 2 }console.log(obj === copy); //false//객체 병합const merged = { x: 1, y:2, ... { a: 3, b: 4 } };console.log(merged); { x: 1, y: 2, a: 3, b: 4 };//// Object.assign 메소드// 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경 또는 추가// 객체 병합// 프로퍼티가 중복되면, 뒤에 위치한 프로퍼티가 우선권const merged = Object.assign({}, { x: 1, y: 2 }, { y: 10 , z: 3 });console.log(merged); // {x: 1, y: 10 , z: 3 }// 특정 프로퍼티 변경const changed = Object.assign({}, { x: 1, y: 2 }, { y: 10 });console.log(changed); // { x: 1, y: 10 }// 프로퍼티 추가const added = Object.assign({}. { x: 1, y: 2 }, { y: 10 , z: 0 });console.log(added); // {x: 1, y: 2, z: 0 }////// 스프레드 문법// 객체 병합// 프로퍼티가 중복되면, 뒤에 위치한 프로퍼티가 우선권const merged = { ...{ x: 1, y: 2 }, ... { y: 10 , z: 3 });console.log(merged); // {x: 1, y: 10 , z: 3 }// 특정 프로퍼티 변경const changed = { ...{ x: 1, y: 2 }, { y: 10 });console.log(changed); // { x: 1, y: 10 }// 프로퍼티 추가const added = { ...{ x: 1, y: 2 }, { z: 0 });console.log(added); // {x: 1, y: 2, z: 0 }","link":"/2020/03/javaScript/js.spreadSyntax/"},{"title":"javaScript/js.this","text":"this 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가(미래에) 생성할 인스턴스 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체 바인딩 - 식별자와 값을 연결하는 과정 ex) 변수는 할당에 의해 값이 바인딩된다. 1. this 키워드동작을 나타내는 메소드는 자신이 속한 객체의 프로퍼티를 참조하고 변경할 수 있어야한다. 이 때 메소드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야한다. 생성자 함수 내부에서는 프로퍼티 또는 메소드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다. 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수가 존재해야 한다. 생성자 함수를 정의하는 시점에서는 아직 인스턴스를 생성하기 이저이므로 생성자 함수가 생성할 인스턴스를 가리키는 식별자를 알 수 없다. 따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요한데 이를 위해 자바스크립트는 this라는 특수한 식별자를 제공한다. this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다. 자바스크립트 엔진에 의해 암묵적으로 생성되며 코드 어디에서든지 참조할 수 있다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다. 2. 함수 호출 방식과 this 바인딩 렉시컬 스코프와 this 바인딩은 결정 시기가 다르다. 함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어 함수 객체가 생성되는 시점에 상위 스코프를 결정한다. this에 바인딩될 객체는 함수 호출 시점에 결정된다. 2.1 일반 함수 호출기본적으로 this는 전역객체가 바인딩된다. 전역 함수는 물론, 중첩함수를 일반함수로 호출하면 함수 내부의 this에 전역 객체가 바인딩된다. (중첩함수, 콜백함수 포함) this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서는 의미가 없다. 2.2 메소드 호출 메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표 연산자 앞에 기술한 객체에 바인딩된다. 메소드 내부의 this는 메소드를 소유한 객체가 아닌 메소드를 호출한 객체에 바인딩된다는 것 메소드는 프로퍼티에 바인딩된 함수이다. 2.3 생성자 함수 호출 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다. 2.4 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다. apply, call 메소드는 Function.prototype의 메소드, 따라서 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다. apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것, apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. Function.prototype.bind 메소드는 함수를 호출하지 않고 this로 사용할 객체만을 전달한다. bind 메소드는 메소드의 this와 메소드의 내부의 중첩함수 또는 콜백함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다.","link":"/2020/03/javaScript/js.this/"},{"title":"javaScript/js.strictMode","text":"엄격모드1. strict modeES5부터 strict mode가 추가되었다.자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적 에러를 발생시킨다. ESlint같은 도구로 비슷한 효과를 얻을 수 있다.린트는 정적분석 기능을 통해 소스코드를 실행하기 전에 소스 코드를 스캔하여 문법적 오류만이 아니라 잠재적 오류까지 찾아내고 오류의 이유도 리포팅 해준다. 2. strict mode의 적용 strict mode를 적용하려면 전역의 선두 또는 함수 몸체 선두에 ‘use strict’;를 추가전역 선두에 추가하면 스크립트 전체에 적용된다. 함수 몸체의 선두에 추가하면 해당 함수와 중첩된 내부 함수에 strict mode 적용 코드의 선두에 strict mode를 위치시키지 않으면 작동하지않는다 (에러발생시키지않음) 3. 전역에 strict mode 적용은 no 스크립트 단위로 적용된 strict mode는 다른 스크립트에 영향을 주지않고 자신의 스크립트에 한정되어 적용한다. strict mode, non-strict mode를 혼용하면 오류를 발생시킬 수 있음 즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고, 함수 선두에 strict mode적용 4. 함수 단위로 strict mode를 적용하는 것도 nostrict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 문제를 발생시킨다. 5. strict mode가 발생시키는 에러5.1 암묵적 전역선언하지 않는 변수를 참조하면 ReferenceError가 발생 123456(function () { 'use strict'; x = 1; console.log(x); // ReferenceError x is not defined}()); 5.2 변수, 함수, 매개변수의 삭제delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생 5.3 매개변수 이름의 중복중복된 함수 매겨변수 이름을 사용하면 SyntaxError가 발생 123456789(function () { 'use strict'; //SyntaxError: Duplicate parameter name not allowed in this context function foo(x, x) { return x + x; } console.log(foo(1, 2));}()); 5.4 with문의 사용with문을 사용하면 SyntaxError 발생 6. strict mode 적용에 의한 변화6.1 알반 함수의 thisstrict mode에서 함수를 일반 함수로서 호출하면 this에 undefined가 바인딩된다.생성자 함수가 아닌 일반 함수 내부에서는 this를 사용할 필요가 없기때문이다. 6.2 arguments 객체strict mode에서는 매개변수에 전달된 인수를 재할당하여 변경하여도 arguments 객체에 반영되지 않는다.","link":"/2020/03/javaScript/js.strictMode/"},{"title":"javaScript/js.typeCasting","text":"타입변환이란?명시적 타입 변환(Explicit coercion), 타입캐스팅(Type casting)개발자가 의도적으로 값의 타입을 변환 암묵적 타입 변환(Implicit coercion), 타입 강제 변환(Type coercion)자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환 두 타입변환이 기존 원시값을 직접 변경하는 것은 아니다. (원시값은 변경 불가능한 값이므로 변경할 수 없음)타입변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다. 암묵적 타입 변환1. 문자열 타입으로 변환11 + '2' //\"12\" +연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다. 2. 숫자 타입으로 변환1231 - '1' // 01 * '10' // 101 / 'one' // NaN 산술 연산자의 역할은 숫자 값을 만드는 것이다.이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다. 1'1' &gt; 0 //true 비교 연산자의 역할은 불리언 값을 만드는 것이다.코드의 문맥상 모두 숫자 타입이어야 한다. 3. 불리언 타입으로 변환if 문이나 for 문 같은 제어문은, 또는 삼항 조건 연산자의 조건식은 불리언 값을 반환해야 하는 표현식이다.자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값 (참으로 평가되는 값) 또는 Falsy 값 (거짓으로 평가되는 값)으로 구분Truthy -&gt; true, Falsy -&gt; false 12Falsy 값false undefined null 0, -0 NaN (빈문자열) 이외의 모든 값은 모두 true로 평가되는 Truthy 값 명시적 타입 변환표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법빌트인 메소드를 사용하는 방법 1. 문자열 타입으로 변환 String 생성자 함수를 new 연산자 없이 호출하는 방법 Object.prototype.toString 메소드를 사용하는 방법 문자열 연결 연산자를 이용하는 방법 2. 숫자 타입으로 변환 Number 생성자 함수를 new 연산자 없이 호출하는 방법 parselnt, parseFloat 함수를 사용하는 방법 (문자열만 숫자 타입으로 변환 가능) +단항 산술 연산자를 이용하는 방법 *산술 연산자를 이용하는 방법 3. 불리언 타입으로 변환 Boolean 생성자 함수를 new 연산자 없이 호출하는 방법 !부정 논리 연산자를 두번 사용하는 방법 단축 평가논리곱(&amp;&amp;)연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환논리합(||)연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환 논리 연산의 결과를 결정한 타입 변환하지 않고 피연산자를 그대로 반환이를 단축 평가 (Short-Circuit evaluation)라 부른다.","link":"/2020/02/javaScript/js.typeCasting/"},{"title":"React/React.Component","text":"Component","link":"/2020/05/React/React.Component/"},{"title":"React/React.HOC ","text":"HOC (Higher Order Function)컴포넌트를 파라미터로 넘겨서 사용하는 방식 파라미터로 컴포넌트를 받아오고, 함수 내부에서 새 컴포넌트를 만든 다음해당 컴포넌트 안에서 파라미터로 받아온 컴포넌트를 렌더링 하는 것 자신이 받아온 props들은 그대로 파라미터로 받아온 컴포넌트에게 다시 주입해주고,필요에 따라 추가 props도 넣어준다. HOC의 이름을 만들땐 with~ 형식으로 짓는다. (ex. withRequest) 장점함수에 기능을 추가하는 코드를 재사용 할 수 있다. 단점콜백지옥? 여러 로직이 componentWillUnmount, componentDidMount 등의 리액트 life cycle에 흩어지게된다.함수는 단일 책임 원칙을 벗어나게되고, 코드는 복잡해지고, 디버깅도 어려워진다. 그래서 나타난게 Hook이다.","link":"/2020/05/React/React.HOC%20/"}],"tags":[],"categories":[]}